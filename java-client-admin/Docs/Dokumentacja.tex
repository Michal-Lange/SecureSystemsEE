\documentclass[12pt,titlepage]{article}
\usepackage[bottom=7em]{geometry}
%\usepackage{amsmath}
%\usepackage{amsfonts}
%\usepackage{amssymb}
%\usepackage{algorithm}
%\usepackage{algorithmic} 
%\usepackage{theorem}
%\usepackage{graphicx}
%
%\usepackage[cp1250]{inputenc}
%\usepackage[T1]{fontenc}
%\usepackage[polish]{babel}
%\usepackage[MeX]{polski}
%
%\usepackage{makeidx}
%\usepackage{listings}
%\usepackage{url}
%\usepackage{Here}
\usepackage{pgfplots}
\pgfplotsset{compat=1.13}

\usepackage{graphicx}
\usepackage{graphics}
\usepackage{epsfig}
\usepackage{mathtools}
\usepackage{amssymb}
\usepackage{amsthm}
\usepackage{booktabs}
\usepackage{stmaryrd}
\usepackage{url}
\usepackage{longtable}
\usepackage[figuresright]{rotating}
%\usepackage[MeX]{polski}
\usepackage[cp1250]{inputenc}
\usepackage[T1]{fontenc}
%\usepackage[latin2]{inputenc}
\usepackage[polish]{babel}
\usepackage{geometry}
\usepackage{pslatex}
\usepackage{ulem}
\usepackage{lipsum}
\usepackage{listings}
\usepackage{url}
\usepackage{Here}
\usepackage{caption}
\usepackage{pdfpages}

\usepackage{color}
\definecolor{szary}{gray}{0.6}% jasnoszary

\setlength{\textwidth}{400pt}
\lstset{numbers=left,
			numberstyle=\tiny, 
			basicstyle=\scriptsize\ttfamily, 
			breaklines=true, 
			captionpos=b, 
			tabsize=2}

\usepackage[ruled,vlined,linesnumbered]{algorithm2e}

\selectlanguage{polish}

\newcommand{\RR}{\mathbb{R}}
\newcommand{\NN}{\mathbb{N}}
\newcommand{\QQ}{\mathbb{Q}}
\newcommand{\ZZ}{\mathbb{Z}}
\newcommand{\TAB}{\hspace{0.50cm}}
\newcommand{\IFF}{\leftrightarrow}
\newcommand{\IMP}{\rightarrow}

\newtheorem{theorem}{Twierdzenie}[section]
\newtheorem{lemma}{Lemat}[section]
\newtheorem{example}{Przyk³ad}[section]
\newtheorem{corollary}{Wniosek}[section]
\newtheorem{definition}{Definicja}[section]

\sloppy

\renewcommand\lstlistlistingname{Spis listingów}

\makeindex

\begin{document}

\pagestyle{empty}

\begin{titlepage}
\includepdf[fitpaper]{pd_mgr.pdf}
\end{titlepage}

\tableofcontents

\newpage

\listoffigures
\addcontentsline{toc}{section}{Spis rysunków}

\newpage

\lstlistoflistings
\addcontentsline{toc}{section}{Spis listingów}

\newpage

\pagestyle{headings}

\section{Wstêp}

S³owo „kryptografia” pochodzi z jêzyka greckiego i mo¿e byæ przet³umaczone jako „ukryte pismo”. Kryptografia pocz¹tkowo opiera³a siê na tajnoœci sposobu przekazywania informacji oraz na steganograficznych sposobach zapisywania informacji w tekstach lub grafikach w taki sposób, aby nawet osoba przewo¿¹ca wiadomoœci nie wiedzia³a, ¿e przewozi jak¹œ tajn¹ wiadomoœæ. Obecnie kryptografia zajmuje siê przekszta³ceniem wiadomoœci w taki sposób, aby sta³a siê niemo¿liwa do odczytania bez u¿ycia specjalnego, tajnego klucza \cite{KryptografiaAsymetrczna1}.

Przekszta³cona w powy¿szy sposób wiadomoœæ nazywana jest szyfrogramem lub krypotogramem, a ca³y proces nazywany jest szyfrowaniem.

W dzisiejszych czasach wiadomoœci wysy³ane, przetwarzane i odczytywane s¹ przy pomocy komputerów lub innych urz¹dzeñ elektronicznych. Kryptografia w kontekœcie dnia dzisiejszego nie zajmuje siê zatem tylko szyfrowaniem tekstów, ale mo¿e byæ równie¿ i jest stosowania do szyfwowania wszelakich informacji przetwarzanych przez systemy komputerowe, takich jak: teksty, obrazy, klipy wideo, muzyka. Dane w systemach komputerowych przechowywane s¹ w postaci cyfrowej i ka¿de takie dane mog¹ byæ zaszyfrowane.

Wspó³czesn¹ kryptografie mo¿na podzieliæ na:
\begin{itemize}
	\item symetryczn¹ -- do szyfrowania i deszyfrowania u¿ywany jest ten sam klucz,
	\item asymetryczn¹ -- do szyfrowania i deszyfrowania u¿ywane s¹ ró¿ne klucze.
\end{itemize}

Kryptografia nie zajmuje siê jednak tylko szyfrowaniem. Poza szyfrowaniem, czyli poufnoœci¹ metody krypograficzne mog¹ zapewniæ:

\begin{itemize}
	\item integralnoœæ - niezmiennoœæ danych w czasie procesu,
	\item uwierzytelnianie - autentycznoœæ, pewnoœæ co do pochodzenia danych,
	\item niezaprzeczalnoœæ - nadawca nie mo¿e siê wyprzeæ przes³ania komunikatu o ustalonej treœci.
\end{itemize}

Powy¿sze cechy mog¹ byæ dostarczone przy pomocy podpisu cyfrowego. Podpis cyfrowy to dodadkowa informacja do³¹czona do danych s³u¿aca do weryfikacji ich Ÿród³a oraz zapewniaj¹ca integralnoœæ, autentycznoœæ i niezaprzeczalnoœæ. Podpisy cyfrowe korzystaj¹ z kryptografii asymetrycznej - tworzona jest para kluczy:

\begin{itemize}
	\item klucz prywatny - s³u¿¹cy do podpisywania wiadomoœci,
	\item klucz publiczny - s³u¿¹cy do weryfikacji wiadomoœci.
\end{itemize}

Ponadto domen¹ kryptografii s¹ takie zagadnienia jak:

\begin{itemize}
	\item dowód z wiedz¹ zerow¹,
	\item g³osowanie elektroniczne,
	\item wspó³dzielenie tajemnic,
	\item obliczenia wielopodmiotowe.
\end{itemize}

Kolejnym zagadnieniem bêd¹cym przedmiotem tej pracy s¹ „systemy rozproszone”. Ze wzglêdu na ró¿norodnoœæ rozwa¿anych aspektów nie istnieje jednolita definicja systemu rozproszonego. Definicja ta ewoluowa³a wraz z rozwojem komputerów oraz sieci komputerowych. Za system rozproszony uwa¿a siê powszechnie zbiór niezale¿nych urz¹dzeñ technicznych (np. komputerów) po³¹czonych w jedn¹, spójn¹ logiczn¹ ca³oœæ (np. przy pomocy sieci komputerowej).

Cechy systemów rozproszonych to\cite{SystemyRozproszone1}:
\begin{itemize}
	\item Ukrycie przed u¿ytkownikami systemu:
		\subitem - ró¿nic pomiêdzy poszczególnymi komputerami,
		\subitem - sposobów komunikowania siê komputerów,
		\subitem - wewnêtrznej organizacji systemu rozproszonego.
	\item Jednolity i spójny interfejs dla u¿ytkownika - niezale¿nie od czasu i miejsca interakcji.
\end{itemize}

Systemy rozproszone s¹ tworzone ze wzglêdu na istotne potencjalne zalety tych systemów. Efektywne zagospodarowanie tych zalet mo¿e sprawiæ, ¿e bêd¹ one bardziej atrakcyjne dla u¿ytkownika koñcowego ni¿ systemy scentralizowane\cite{SystemyRozproszone1}.

Nastêpnym elementem wystêpuj¹cym w temacie, a tak¿e bêd¹cym nieod³¹czym elementem tego opracowania jest „wieloplatformowoœæ”. Wieloplatformowoœæ jest to cecha systemu lub aplikacji, który dzia³a na wiêcej ni¿ jednej platformie. Platforma to kombinacja sprzêtu i oprogramowania, na której uruchamiana jest aplikacja lub system. Platforma sprzêtowa mo¿e odnosiæ siê do architektury procesora lub architektury komputera. Platforma systemowa odnosi siê do systemu operacyjnego lub maszyny wirtualnej, mo¿e byæ tak¿e kombinacj¹ obydwu. U¿ytkownik stosuje okreœlony program po to, aby zrealizowaæ konkretne zadanie. Tak d³ugo, dopó³ki funkcjonowanie aplikacji nie zale¿y od platformy, w której siê wykonuje, dla u¿ytkownika jest ca³kowicie obojêtne na jakiej platformie jest uruchamiana. Platforma sprzêtowa i programowa stanowi¹ jedynie œrodowisko dla uruchamiania systemów i aplikacji, same w sobie bez oprogramowania s¹ bezu¿yteczne.

\newpage

\subsection{Cel pracy}

Celem pracy jest zaprojektowanie, zaimplementowanie oraz wdro¿enie systemu komputerowego umo¿liwiaj¹cego bezpieczn¹ komunikacjê u¿ytkowników oraz cyfrowe podpisywanie plików, a tak¿e weryfikacjê cyfrowo podpisanych plików. Dla uzyskania wiêkszego bezpieczeñstwa generowanie klucza dla podpisu cyfrowego oraz podpisywanie plików bêdzie rozproszone, a wiêc odbywaæ siê ono bêdzie w kilku miejscach systemu.

Wynikiem pracy bêdzie system rozproszony, którego u¿ytkownicy koñcowi bêd¹ mogli z korzystaæ z niego pracuj¹c na ró¿nych platformach sprzêtowych i programowych. Ponadto system bêdzie zaprojektowany równie¿ w taki sposób, aby przy mo¿liwie ma³ych zmianach lub bez nich móg³ byæ uruchamiany na ró¿nych platformach.
W pracy zostan¹ przeprowadzone testy aplikacji oraz zastosowanych mechanizmów kryptograficznych.

\subsection{Zakres pracy}

Pierwszym elementem pracy jest zaprojektowanie i zaimplementowanie aplikacji dzia³aj¹cej na serwerze, która funkcjonowaæ bêdzie jako punkt dostêpowy dla u¿ytkowników systemu czyli klientów. Kolejnym elementem bêdzie mediator, bêdzie to czêœæ systemu, która bêdzie uczestniczyæ przy generowaniu klucza dla podpisu cyfrowego oraz bêdzie bra³a udzia³ przy podpisywaniu plików. Klienci chc¹cy korzystaæ z systemu bêd¹ musieli posiadaæ aplikacje klienck¹, która bêdzie kolejnym elementem systemu. Administratorzy bêd¹ posiadali specjaln¹ wersjê klienta, za pomoc¹ której bêdzie mo¿na dodawaæ, edytowaæ lub usuwaæ u¿ytkowników systemu.

\newpage

\section{Analiza wymagañ i za³o¿enia projektowe}

W niniejszym rozdziale zawarto analizê wymagañ funkcjonalnych i niefunkcjonalnych oraz za³o¿enia stawiane przed systemem.

\subsection{Koncepcja dzia³ania systemu}

W sk³ad systemu wchodz¹ nastêpuj¹ce komponenty:

\begin{itemize}
	\item \texttt{serwer dostêpowy},
	\item \texttt{mediator},
	\item \texttt{klient},
	\item \texttt{administrator klient}.
\end{itemize}

G³ównym wêz³em systemu jest \texttt{serwer dostêpowy}. Serwer ten przechowuje informacje o zarejstrowanych u¿ytkownikach systemu w bazie danych oraz implementuje logikê biznesow¹. Serwer ten jest punktem dostêpowym, do którego przy pomocy aplikacji klienckiej ³¹cz¹ siê u¿ytkownicy.

U¿ytkownik koñcowy przy dostêpie do systemu korzysta z aplikacji \texttt{klient}, która oferuje graficzny interfejs u¿ytkownika. Aplikacja kliencka komunikuje siê bezpoœrednio jedynie z serwerem dostêpowym. Aplikacja \texttt{Klient} umo¿liwia wymianê wiadomoœci z innymi u¿ytkownikami systemu, a tak¿e podpisywanie cyfrowe plików oraz weryfikacjê podpisów cyfrowych.

\texttt{Mediator} jest to osobny serwer, a zarazem wêze³ systemu, który bierze udzia³ podczas generowania kluczy dla podpisu cyfrowego, a tak¿e podczas procesu podpisywania pliku. \texttt{Mediator} posiada w³asn¹ bazê danych, w której przechowuje swoje czêœci kluczy prywatnych u¿ytkowników.

\texttt{Administrator Klient} to aplikacja, dziêki której mo¿na dodawaæ, edytowaæ i usuwaæ u¿ytkowników systemu. Komunikuje siê ona bezpoœrednio z \texttt{serwerem dostêpowym}.

\newpage

\subsubsection{Komponenty systemu}

\begin{figure}[h!]
\begin{center}
\includegraphics[width=1\textwidth]{system.pdf}
\end{center}
\caption{Kierunek wywo³ywania komponetów systemu.} \label{system1}
\end{figure} 

\newpage

\subsection{Wymagania funkcjonalne}

Wymagania funkcjonalne dla systemu to:
\begin{itemize}
	\item Mo¿liwoœæ dostêpu do systemu jedynie po pomyœlnym zalogowaniu.
	\item Oprócz \texttt{nazwy u¿ytkownika} i \texttt{has³a}, system przydziela ka¿demu u¿ytkownikowi specjalny \texttt{klucz serwisowy}, który u¿ywany jest przy komunikacji pomiêdzy \texttt{serwerem dostêpowym} a \texttt{aplikacj¹ klienck¹} oraz pomiêdzy \texttt{serwerem dostêpowym} a \texttt{mediatorem} oraz s³u¿y jako dodadkowy element walidacji.
	\item Wymiana \texttt{wiadomoœci tekstowych} z innymi \texttt{u¿ytkownikami} w trybie rzeczywistym poprzez sieæ internet.
	\item Dostêpna \texttt{lista kontaktów} z mo¿liwoœci¹ modyfikacji, czyli:
		\subitem - dodawanie nowego kontaktu,
		\subitem - edytowanie kontaktu,
		\subitem - usuwanie kontaktu.
	\item Przechowywanie \texttt{listy u¿ytkowników} lokalnie w \texttt{pliku XML}.
	\item Przechowywanie \texttt{konfiguracji klienta} w lokalnym \texttt{pliku konfiguracyjnym}.
	\item Powiadomienie o otrzymaniu nowej \texttt{wiadomoœci} od innego \texttt{u¿ytkownika} systemu.
	\item Generowanie \texttt{kluczy} dla \texttt{podpisu cyfrowego}:
	\item Generowanie \texttt{kluczy} wymaga ponownej autoryzacji (podanie \texttt{loginu} i \texttt{has³a})
	\item Podczas generowania \texttt{klucz prywatny} dzielony jest na dwie czêœci:
		\subitem - \texttt{czêœæ prywatna u¿ytkownika} - przechowywan¹ przez \texttt{aplikacje klienck¹},
		\subitem - \texttt{czêœæ prywatna mediatora} - przechowywan¹ w \texttt{mediatorze}.
	\item Cyfrowe \texttt{podpisywanie plików}.
	\item \texttt{Podpisywanie pliku} odbywa siê dwuetapowo. Pierwszy etap odbywa siê w \texttt{aplikacji klienckiej}, za pomoc¹ \texttt{czêœci prywatnej klucza u¿ytkownika}. Czêœciowy \texttt{podpis} finalizowany jest przez \texttt{mediatora} za pomoc¹ \texttt{czêœci prywatnej klucza mediatora}.
	\item Weryfikacja \texttt{podpisanego pliku}.
	\item Weryfikacja odbywa siê po stronie \texttt{aplikacji klienckiej}.
	\item Osobna aplikacja \texttt{klient do administracji} do zarz¹dzania systemem posiadaj¹ca nastêpuj¹ce funkcjonalnoœci:
	\subitem - dodawanie \texttt{u¿ytkownika systemu},
	\subitem - edytowanie \texttt{u¿ytkownika systemu},
	\subitem - kasowanie \texttt{u¿ytkownika systemu}.
\end{itemize}

\newpage

\subsubsection{Diagram przypadków u¿ycia}

\begin{figure}[h!]
\begin{center}
\includegraphics[width=0.8\textwidth]{useCase.pdf}
\end{center}
\caption{Diagram przypadków u¿ycia.} \label{useCase1}
\end{figure} 

\newpage

\subsubsection{Scenariusze wybrancyh przypadków u¿ycia}
W rozdziale tym przedstawione zosta³y wybrane scenariusze przypadków u¿ycia.
\\
\textbf{Scenariusz do przypadku u¿ycia: \textit{Generuj parê kluczy}}\\
\\
\\
\begin{tabular}{|p{14cm}|}
\hline
\textbf{Warunki pocz¹tkowe}
\begin{enumerate}
	\item System jest poprawnie skonfigurowany i dzia³a prawid³owo.
	\item \texttt{U¿ytkownik} ma uruchomionego \texttt{klienta} i jest zalogowany do systemu oraz posiada swój w³asny unikalny \texttt{klucz serwisowy}.
\end{enumerate}\\
\hline
\textbf{G³ówny ci¹g zda¿eñ}
\begin{enumerate}
	\item \texttt{U¿ytkownik} przechodzi do zak³adki \texttt{konfiguracja}.
	\item \texttt{U¿ytkownik} klika w przycisk \texttt{zarz¹daj now¹ parê kluczy}.
	\item \texttt{U¿ytkownik} podaje prawid³owy \texttt{login} i \texttt{has³o}, a nastêpnie klika w przycisk \texttt{generuj klucze}.
	\item Zostaje wys³ane ¿¹danie do \texttt{serwera dostêpowego} o wygenerowanie nowej \texttt{pary kluczy}.
	\item \texttt{Para kluczy} zostaje wygenerowana. \texttt{Klucz prywatny} zostaje podzielony pomiêdzy \texttt{mediatorem} i \texttt{u¿ytkownikiem}.
	\item Zostaje wyœwietlona informacja o \texttt{kluczu} oraz jego poprawnym wygenerowaniu.
\end{enumerate}\\
\hline
\textbf{Scenariusz alternatywny}
\begin{enumerate}
	\item \texttt{U¿ytkownik} podaje nieprawid³owy \texttt{login} lub \texttt{has³o}.
	\item Po wciœniêciu przycisku \texttt{generuj klucze} zostaje wyœwietlony komunikat o b³êdzie.
\end{enumerate}\\
\hline
\textbf{Scenariusz alternatywny 2}
\begin{enumerate}
	\item Któryœ z wêz³ów systemu: \texttt{mediator} lub \texttt{serwer dostêpowy} s¹ niedostêpne.
	\item Po wciœniêciu przycisku  \texttt{generuj klucze} zostaje wyœwietlony komunikat o b³êdzie.
\end{enumerate}\\
\hline
\end{tabular}

\newpage

\textbf{Scenariusz do przypadku u¿ycia: \textit{Podpisz plik}}\\
\\
\\
\begin{tabular}{|p{14cm}|}
\hline
\textbf{Warunki pocz¹tkowe}
\begin{enumerate}
	\item System jest poprawnie skonfigurowany i dzia³a prawid³owo.
	\item \texttt{U¿ytkownik} ma uruchomionego \texttt{klienta} i jest zalogowany do systemu oraz posiada swój w³asny unikalny \texttt{klucz serwisowy}.
	\item \texttt{U¿ytkownik} wygenerowa³ \texttt{parê kluczy}, posiada swoj¹ czêœæ prywatn¹, a druga czêœæ znajduje siê na \texttt{mediatorze}.
\end{enumerate}\\
\hline
\textbf{G³ówny ci¹g zda¿eñ}
\begin{enumerate}
	\item \texttt{U¿ytkownik} przechodzi do zak³adki \texttt{podpis cyfrowy}.
	\item \texttt{U¿ytkownik} klika w przycisk \texttt{wczytaj plik}, a nastêpnie wskasuje plik, który ma zostaæ podpisany.
	\item \texttt{U¿ytkownik} klika w przycisk \texttt{podpisz plik}.
	\item \texttt{Aplikacja kliencka} sk³ada czêœciowy podpis.
	\item Zostaje wys³ane ¿¹danie do \texttt{serwera dostêpowego} o ¿¹danie podpisu.
	\item Zwrócony zostaje sfinalizowany podpis pliku
	\item \texttt{U¿ytkownik} dostaje informacjê o podpisie cyfrowym i ma mo¿liwoœæ jego zapisania.
\end{enumerate}\\
\hline
\textbf{Scenariusz alternatywny}
\begin{enumerate}
	\item \texttt{Klucz prywatny} \texttt{u¿ytkownika} nie jest kompatybilny z \texttt{czêœci¹ prywatn¹ klucza mediatora}.
	\item Po wciœniêciu przycisku  \texttt{podpisz plik} zostaje wyœwietlony komunikat o b³êdzie.
\end{enumerate}\\
\hline
\textbf{Scenariusz alternatywny 2}
\begin{enumerate}
	\item Któryœ z wêz³ów systemu: \texttt{mediator} lub \texttt{serwer dostêpowy} s¹ niedostêpne.
	\item Po wciœniêciu przycisku \texttt{podpisz plik} zostaje wyœwietlony komunikat o b³êdzie.
\end{enumerate}\\
\hline
\end{tabular}

\newpage

\textbf{Scenariusz do przypadku u¿ycia: \textit{Wyœlij wiadomoœæ}}\\
\\
\\
\begin{tabular}{|p{14cm}|}
\hline
\textbf{Warunki pocz¹tkowe}
\begin{enumerate}
	\item System jest poprawnie skonfigurowany i dzia³a prawid³owo.
	\item \texttt{U¿ytkownik} posiada na \texttt{liœcie kontaktów} \texttt{kontakt} do którego chce wys³aæ \texttt{wiadomoœæ}.
	\item \texttt{U¿ytkownik} ma uruchomionego \texttt{klienta}, jest zalogowany do systemu oraz posiada swój w³asny unikalny \texttt{klucz serwisowy}.
\end{enumerate}\\
\hline
\textbf{G³ówny ci¹g zda¿eñ}
\begin{enumerate}
	\item \texttt{U¿ytkownik} przechodzi do zak³adki \texttt{komunikator}.
	\item \texttt{U¿ytkownik} klika w \texttt{kontakt}, do którego chce wys³aæ \texttt{wiadomoœæ}, a nastêpnie w \texttt{oknie wiadomoœci} wpisuje \texttt{wiadomoœæ}.
	\item \texttt{U¿ytkownik} klika w przycisk \texttt{wyœlij wiadomoœæ}.
	\item \texttt{Wiadomoœæ} zostaje wys³ana do odbiorcy.
\end{enumerate}\\
\hline
\textbf{Scenariusz alternatywny}
\begin{enumerate}
	\item Któryœ z wêz³ów systemu: \texttt{mediator} lub \texttt{serwer dostêpowy} s¹ niedostêpne.
	\item Po wciœniêciu przycisku \texttt{podpisz plik} zostaje wyœwietlony komunikat o b³êdzie.
\end{enumerate}\\
\hline
\end{tabular}

\newpage

\subsection{Wymagania niefunkcjonalne}

Projektowany system musi spe³niaæ równierz szereg wymagañ niefunkcjonalnych, które zosta³y przedstawione w kolejnych podpunktach.

\subsubsection{Bezpieczeñstwo}

Kluczowym wymaganiem niefunkcjonalnym projektowanego systemu jest bezpieczeñstwo.

\begin{itemize}
	\item Komunikacja pomiêdzy \texttt{aplikacj¹ klienck¹}, a \texttt{serwerem dostêpowym} powinna odbywaæ siê w bezpiecznym kanale np HTTPS.
	\item \texttt{Mediator} nie powinien byæ dostêpny z sieci internet, ale powinien byæ umiejscowiony w sieci wewnêtrznej za firewallem i byæ dostêpny dla \texttt{serwera dostêpowego}.
	\item \texttt{Serwer dostêpowy} powinien zostaæ umiejscowiony w strefie zdemilitaryzowanej DMZ sieci lokalnej i byæ dostêpny z sieci internet oraz mieæ dostêp do \texttt{mediatora}.
\end{itemize}

\subsubsection{Wykorzystywane œrodowiska, technologie i narzêdzia}

Z systemu powinni móc korzystaæ u¿ytkownicy niezale¿nie od systemu operacyjnego, na którym pracuj¹. Sam system powinien przy znikomych zmianach lub bez nich byæ uruchomialny na innej platformie oraz wspó³pracowaæ z ró¿nymi bazami danych.

\begin{itemize}
	\item \texttt{Aplikacja kliencka} bêdzie napisana w technologii \texttt{Java SE 1.8}. Maszyna wirtualna Java dzia³a na systemach \texttt{Windows}, \texttt{Linux}, \texttt{Mac OS} oraz na wielu platformach sprzêtowych.
	\item \texttt{Serwer dostêpowy} oraz \texttt{mediator} bêd¹ napisane w technologii \texttt{Java EE 7}. Aplikacje \texttt{Java EE} mo¿na uruchamiaæ na wielu platformach serwerowych, które pracuj¹ na ró¿nych platformach sprzêtowych i systemowych.
	\item Baza danych dla \texttt{serwera dostêpowego} i \texttt{mediatora} powinna byæ zdefiniowana w serwerze aplikacji.
	\item Do budowania wszystkich projektów u¿ywane bêdzie narzêdzie \texttt{Maven 3.3}.
	\item \texttt{Serwer dostêpowy} oraz \texttt{mediator} domyœlnie bêd¹ uruchamiane i testowane na serwerze aplikacji \texttt{Glassfish 4.1} oraz z baz¹ danych \texttt{MySql 5.7}.
	\item Komunikacja miêdzy elementami systemu bêdzie odbywaæ siê za pomoc¹ web serwisów typu \texttt{REST}.
	\item Wszystkie elementy sytemu bêd¹ napisane przy pomocy zinegrowanego œrodowiska programistycznego \texttt{Eclipse JEE Mars 4.5.1}.
\end{itemize}

\subsubsection{Dostêpnoœæ}

\begin{itemize}
	\item Mo¿liwoœæ korzystania z systemu 7 dni w tygodniu, 24h na dobê z wyj¹tkiem przerwy na zarz¹dzanie i konserwacjê (œrednio 5h w miesi¹cu).
	\item Mo¿liwoœc korzystania z systemu z sieci internet.
\end{itemize}

\subsubsection{Inne wymagania}

\begin{itemize}
	\item Legalne funkcjonowanie systemu bez zakupu licencji na dodadkowe oprogramowanie.
	\item System napisany modu³owo, umo¿liwiaj¹cy ³¹tw¹ modyfikacjê funkcjonalnoœci, rozszerzalnoœæ oraz ponowne u¿ycie kodu.
	\item \texttt{U¿ytkownik} powinien logowaæ siê do systemu jednoczeœnie tylko z jednej lokalizacji.
	\item \texttt{Aplikacja kliencka} posiada intuicyjny i estetyczny interfejs graficzny. 
\end{itemize}

\newpage

\section{Analiza zastosowanych metod i technologii}

W tym rozdziale omówione zastosta³y g³ówne pojêcia, technologie stosowane w systemie oraz metody wykorzystywane podczas jego tworzenia. W ostatnim podrozdziale przedstawiony zosta³ model matematyczny podpisu cyfrowego, na podstawie którego utworzona zosta³a implementacja w systemie.

\subsection{Aplikacja Enterprise}

Nie ma jednoznacznej definicji opisuj¹cej aplikacjê typu enterprise, istnieje jednak wiele cech i w³aœciwoœci, które charakteryzuj¹ tego typu oprogramowanie. S¹ to miêdzy innymi:

\begin{itemize}
	\item skalowalnoœæ – to w³aœciwoœæ, która charakteryzuje system przygotowany na wzrost liczby u¿ytkowników zarówno pod wzglêdem architektonicznym (rozszerzalnoœæ kodu) jak i wydajnoœciowym(np. load balancing),
	\item podzia³ na warstwy, w dobrze zaprojektowanym systemie mo¿na wyró¿niæ:
		\subitem - warstwê klienta,
		\subitem - warstwê prezentacji,
		\subitem - warstwê biznesow¹,
		\subitem - warstwê integracji,
		\subitem - warstwê zasobów; 
	\item bezpieczeñstwo - system powinien byæ odporny na ataki z zewn¹trz oraz spe³niaæ aktualnie przyjête normy bezpieczeñstwa,
	\item modularnoœæ - elementy systemu powinny byæ pogrupowane w modu³y,
	\item oddzielenie komponentów technicznych oraz logiki biznesowej,
	\item wysoce skompikowane systemy implementowane i wdra¿ane przez wiele lat,
	\item odpornoœæ na awarie - uzyskiwan¹ np. poprzez redundancjê krytycznych elementów systemu,
	\item systemy rozproszone,
	\item ³atwoœæ odzyskiwania po awarii - uzyskiwan¹ np. poprzez automatyczne i regularne tworzenie kopii zapasowych aktualnego stanu aplikacji.
\end{itemize}

\subsubsection{Technologie Java Enterprise Edition}

Java EE lub inaczej Java Enterprise Edition jest to platforma programistyczna jêzyka Java, s³u¿¹ca do pisania aplikacji biznesowych. Java EE posiada wszystkie elementy oraz zalety platformy Java SE, dziêki czemu jest w pe³ni przenoœna, mo¿e byæ implementowana oraz wdra¿ana na dowolnym systemie operacyjnym posiadaj¹cy wirtualn¹ maszynê Javy (JVM). Jave EE rozszerza wersjê SE o zbiór komponentów przeznaczonych do tworzeniaw aplikacjach klasy enterprise.
Komponenent Javy EE jest niezale¿n¹, funkcjonaln¹ jednostk¹ oprogramowania wbudowywan¹ w aplikacjê JEE (wraz z powi¹zanymi z nim klasami i plikami) i komunikuj¹c¹ siê z innymi komponentami\cite{JavaEE6Przewodnik1}. Java EE 7 wprowadzi³a szereg adnotacji, dziêki którym zbêdne staje siê przechowywanie du¿ej czêœci konfiguracji w plikach XML.

W specyfikacji Javy EE zdefiniowano nastêpuj¹ce komponenty\cite{JavaEE6Przewodnik1}:

\begin{itemize}
	\item aplikacje klienckie i aplety s¹ komponentami uruchamianymi po stronie klienta,
	\item komponenty technologii Java Servlet, JavaServer Faces oraz JavaServer Pages (JSP) s¹ komponentami webowymi dzia³aj¹cymi na serwerze,
	\item komponenty Enterprise JavaBeans (zwane tak¿e ziarnami EJB) bêd¹ce komponentami biznesowymi dzia³aj¹cymi na serwerze.
\end{itemize}
  
Warstwy aplikacji zosta³y przedstawione na rysunku \ref{jee1}.

\newpage

\begin{figure}[h!]
\begin{center}
\includegraphics[width=0.8\textwidth]{jee.png}
\end{center}
\caption{Wielowarstwowa aplikacja w technologii Java EE\cite{JavaEETutorial1}.} \label{jee1}
\end{figure}

\newpage

\subsubsection{Serwer i kontenery Java EE}

Aplikacja Java EE uruchamiana jest na serwerze Javy EE. Serwery aplikacji Javy EE to np:

\begin{itemize}
	\item Apache Geronimo,
	\item GlassFish,
	\item JBoss Application Server,
	\item ObjectWeb JOnAS,
	\item IBM WebSphere Application Server,
	\item Oracle WebLogic Server,
	\item Oracle AS/OC4J (nierozwijany, porzucony na rzecz WebLogic Server),
	\item SAP Web Application Server.
\end{itemize}

Serwer Javy EE zawierea kontenery przeznaczone do przechowywania oraz uruchamiania poszczególnych czêœci aplikacji. Na rysunku \ref{jeeContainer1} przedstawiony zosta³ serwer Javy EE oraz osadzone na nim kontenery.

\begin{itemize}
	\item Serwer Javy EE - œrodowisko uruchomieniowe dla aplikacji JEE. Serwer Javy EE dostarcza kontenery EJB oraz kontenery webowe.
	\item Kontener Enterprise JavaBeans(EJB) - zarz¹dza wykonywaniem ziaren EJB w aplikacjach JEE. Komponenty EJB i ich kontener dzia³aj¹ na serwerze Javy EE.
	\item Kontener webowy - zarz¹dza dzia³aniem stron internetowych, serwletów i niektórych komponentów EJB aplikacji JEE. Komponenty webowe i ich kontener dzia³aj¹ na serwerze Javy EE
	\item Kontener aplikacji klienckich - zarz¹dza dzia³aniem komponentów aplikacji klienckiej. Aplikacje klienckie i ich kontener dzia³aj¹ po stronie klienta.
\end{itemize}

\newpage

\begin{figure}[h!]
\begin{center}
\includegraphics[width=0.8\textwidth]{jeeContainer.png}
\end{center}
\caption{Serwer i kontenery Javy EE\cite{JavaEETutorial1}.} \label{jeeContainer1}
\end{figure}

\newpage

\subsubsection{Enterprise JavaBeans}

Komponenty EJB (Enterprise JavaBeans) zwane tek¿e ziarnami EJB, s¹ fragmentami kodu zawieraj¹cymi pola oraz metody implementuj¹ce czêœæ logiki biznesowej. Komponenty EJB umo¿liwiaj¹ tworzenie i wdra¿anie rozproszonych aplikacji na bazie komponentów, które oferuj¹ skalowalnoœæ, mo¿liwoœc przetwarzania transakcyjnego i bezpieczeñstwo.
Za zarz¹dzanie instancj¹ komponentu w czasie wykonywania odpowiada kontener. Klient uzyskuje dostêp do komponentu za poœrednictwem kontenera, w którym dany komponent zosta³ wdro¿ony. Klient mo¿e te¿ dzia³aæ po stronie serwera i mieæ na przyk³ad postaæ komponentu zarz¹dzalnego, komponentu CDI lub serwletu\cite{JavaEE6Leksykon1}.

Istniej¹ trzy rodzaje komponentów EJB:

\begin{itemize}
	\item komponenty sesyjne, dziel¹ siê na:
		\subitem - stanowe - ka¿dy komponent przechowuje unikalny stan, np. stan komunikacji z klientem;
		\subitem - bezstanowe - komponenty te wbrew nazwie te¿ posiadaj¹ swój unikalny stan, jednak nie mo¿e byæ on powi¹zany bezpoœrednio z ¿¹daniem, na które mo¿e zostaæ zwrócony inny komponent tego samego typu,
		\subitem - singletony - unikalne komponenty na skalê œrodowiska uruchomieniowego, przechowuj¹ce np stan aplikacji;
	\item komponenty sterowane komunikatami - komponenty wykorzystywane podczas komunikacji w technologii JMS;
	\item komponenty encyjne - komponenty przechowuj¹ce encje danych, od wersji EJB 3.0 oznaczone s¹ jako przestarza³e, a do przechowywania encji zaleca siê stosowanie klaz z adnotacj¹ @Entity.
\end{itemize}

\subsubsection{Mapowanie obiektowo-relacyjne}

Mapowanie obiektowo-relacyjne (ORM) jest to sposób odwzorowania obiektowej architektury systemu informatycznego na bazê danych (lub inny element systemu) o relacyjnym charakterze. Implementacja takiego odwzorowania stosowana jest m.in. w przypadku, gdy tworzony system oparty jest na podejœciu obiektowym, a system bazy danych operuje na relacjach. 

JavaPersistence API (JPA) jest standardem ORM dla jêzyka Java. Z punktu widzenia programisty jest to mo¿liwoœæ operowania na obiektach - zwanych encjami - oraz zapisywania wyników operacji do relacyjnej bazy danych za pomoc¹ obiektu EntityManager. Sposób w jaki obiekty i ich po³¹czenia przek³adaj¹ siê na elementy bazy danych s¹ definiowane za pomoc¹ adnotacji lub dokumentów XML. Poza standardowym zestawem operacji udostêpnianych przez obiekt EntityManager standard JPA definiuje jêzyk zapytañ JPA Query Language podobny do SQL.\cite{Jersey1}. Encje w JPA oznaczane s¹ adnotacj¹ @Entity.

\subsection{Us³ugi sieciowe typu REST}

REST to akronim od representational state transfer. REST jest us³ug¹ sieciow¹ zaimplementowan¹ na bazie protoko³u HTTP. REST to te¿ architektura, która okreœla model i zasady umo¿liwiaj¹ce budowanie rozwi¹zañ, pozwalaj¹cych na bardzo du¿¹ skalowalnoœæ, wydajnoœæ i ³atwoœæ modyfikacji. W architekturze REST dane i funkcjonalnoœæ reprezentowane s¹ jako zasób. Ka¿dy zasób reprezentowany jest przez oddzielny URL. REST oprócz zasobów reprezentowanych przez Uri to równie¿ kwestia reprezentacji - dany zasób mo¿e byæ reprezentowany jako wynik typu XML, Json, Text, Html, Image oraz wiele innych typów. Komunikacja REST jest bezstanowa. Us³ugi sieciowe (web serwisy) typu REST nazywane s¹ te¿ serwisami RESTful.

Us³ugi REST korzystaj¹ zazwyczaj z czterech metod. Metody te to:

\begin{itemize}
	\item Get -- u¿ywana przy dostêpie do zasobu,
	\item Put -- u¿ywana przy tworzeniu zasobu oraz przy innych operacjach,
	\item Update -- u¿ywana przy aktualizacji zasobu,
	\item Delete -- u¿ywana do kasowania zasobu.
\end{itemize}

\subsubsection{Interfejs JAX-RS oraz implementacja Jersey}

JAX-RS (od ang. Java API for RESTful web services) to API jêzyka Java, które powsta³o w celu u³atwienia tworzenia aplikacji opartych o architekturê REST. Od wersji 2.0 JAX-RS definiuje interfejs sterowany adnotacjami. Adnotacje JAX-RS s¹ adnotacjami œrodowiska uruchomieniowego Java EE. Po uruchomieniu w kontenerze Java EE w œrodowisku uruchomieniowy zostaj¹ wygenerowane klasy pomocnicze oraz artefakty niezbêdne do dzia³ania web serwisu, nastêpnie us³uga jest automatycznie konfigurowana, po czyn zostaje udostêpniona\cite{JavaEE6Przewodnik1}.

JAX-RS oferuje miêdzy innymi nastêpuj¹ce adnotacje:

\begin{itemize}
	\item @Path -- jest wzglêdn¹ œcie¿k¹ URI wskazuj¹c¹ miejsce hostowania klasy Javy,
	\item @GET -- metody oznaczone tym desygnatorem bêd¹ obs³ugiwa³y ¿¹dania GET,
	\item @POST -- metody oznaczone tym desygnatorem bêd¹ obs³ugiwa³y ¿¹dania POST,
	\item @PUT -- metody oznaczone tym desygnatorem bêd¹ obs³ugiwa³y ¿¹dania PUT,
	\item @DELETE - metody oznaczone tym desygnatorem bêd¹ obs³ugiwa³y ¿¹dania DELETE,
	\item @HEAD -- metody oznaczone tym desygnatorem bêd¹ obs³ugiwa³y ¿¹dania HEAD,
	\item @PathParam -- adnotacja ta s³u¿y do wyekstrahowania parametru z URI. nazwy parametrów odpowiadaj¹ nazwom zmiennych okreœlonych we wzorcu URI,
	\item @QueryParam -- adnotacja ta s³u¿y do wyekstrahowania parametru z URI, parametry zapytania s¹ ekstrahowane z parametrów zapytania adresu URI;
	\item @Consumes -- u¿ywana do okreœlenia przetwarzanych przez zasób typów MIME,
	\item @Produces -- u¿ywana do okreœlenia zwracanych przez zasób tymów MIME
	\item @Provider -- adnotacj¹ t¹ oznacza siê wszystkie elementy, które mog¹ byæ potrzebne w œrodowisku uruchomieniowym.
\end{itemize}

Istnieje szereg dalszych adnotacji np: @MatrixParam, @HeaderParam, @CookieParam, @FormParam, @DefaultValue, @Context.

Jersey jest to referencyjna implementacja JAX-RS w Javie. Jersey to framework o otwartym Ÿródle, oferuj¹cy równie¿ szereg funkcjonalnoœci wykraczaj¹cych poza standardowe API JAX-RS np. implementacjê klienta REST.

\subsubsection{Asynchronicznoœæ i Long Pooling}

Typowe ¿¹dania typu REST przetwarzane s¹ w trybie synchronicznym tzn. klient wysy³a ¿¹danie, serwer je przetwarza i zwraca odpowied¿. ¯¹dania synchroniczne stosuje siê wtedy gdy reprezentowany przez URI zasób mo¿e byæ odrazu zwrócony.
W przypadku, gdy zasób nie jest od razu dostêpny lub jego przygotowanie trwa zbyt d³ugo ¿¹danie synchroniczne zakoñczy siê niepowodzeniem.
W takim przypadku nale¿y stosowaæ ¿¹dania asynchroniczne. Przetwarzanie asynchroniczne polega na tym, ¿e serwer nie zwraca odrazu ¿¹dania, lecz przekazuje je do innego w¹tku, gdzie odpowiedŸ na ¿¹danie jest przygotowywana. Gdy zasób zostanie utworzony jest on zwracany do klienta.
Istnieje technika przetwarzania asynchronicznego, która nazywa siê Long Pooling. Polega ona na tym, ¿e klient wysy³a ¿¹danie do serwera. W przypadku gdy zasób nie jest dostêpny lub nie mo¿e zostaæ od razu utworzony to ¿¹danie przechodzi w tryb oczekuj¹cy i zwrócone zostanie dopiero wtedy, gdy zasób bêdzie dostêpny. Technikê tak¹ stosuje siê np. w komunikatorach. Klient wysy³a ¿¹danie, które zwrócone zostanie dopiero wtedy, gdy inny klient wyœle do niego wiadomoœæ.

\newpage

\subsubsection{Filtry}

Interfejs JAX-RS oferuje szereg filtrów. Filtry mog¹ byæ stosowane np. w celu modyfikacji, odrzucenia, czy przekierowania ¿¹dania. Przy pomocy filtrów mo¿na np. uwierzytelniæ nadawcê ¿¹dania. Filtrowanie w JAX-RS odbywa siê potokowo, tzn. mo¿na zdefiniowaæ kilka filtrów oraz ich kolejnoœæ. Filtry w JAX-RS dziel¹ siê na trzy grupy:

\begin{itemize}
	\item PreMatch Filters -- s¹ to filtry które stosowane s¹ do ¿¹dania jescze przed dopasowaniem do danego zasobu.
 	\item Request Filters -- filtry te stosowane s¹ po filtrach PreMatch oraz po tym jak ¿¹danie zosta³o dopasowane do zasobu, ale przed wykonaniem metody zasobu.
	\item Response Filters -- s¹ to filtry, które stosowane s¹ do odpowiedzi na ¿¹danie. Filtry te stosowane s¹ po zakoñczeniu metody zasobu, ale przed odes³aniem zasobu do klienta. Mog¹ operowaæ na danych zwróconych przez zasób.
\end{itemize}
Przetwarzanie potokowe filtrów w JAX-RS 2.0 zosta³o przedstawione na rysunku \ref{jaxrsPipeline1}.

\newpage

\begin{figure}[h!]
\begin{center}
\includegraphics[width=1\textwidth]{jaxrsPipeline.png}
\end{center}
\caption{Przetwarzanie potokowe filtrów w JAX-RS 2.0\cite{JaxRSFilters1} }\label{jaxrsPipeline1}
\end{figure} 

\newpage

\subsection{Podpis cyfrowy}

Podpis cyfrowy to matematyczny sposób sprawdzenia autentycznoœci danych elektronicznych. Zweryfikowany podpis cyfrowy oznacza, ¿e dane pochodz¹ od w³aœciwego nadawcy, który nie mo¿e zaprzeczyæ faktowi ich podpisania oraz ¿e dane od momentu podpisu nie zosta³y zmienione. 

Podpis cyfrowy zapewnia nastêpuj¹ce funckcje bezpieczeñstwa:
\begin{itemize}
	\item autentycznoœci pochodzenia, która daje pewnoœæ co do autorstwa danych,
	\item niezaprzeczalnoœci, która utrudnia wyparcie siê autorstwa lub znajomoœci treœci danych,
	\item integralnoœci, która pozwala wykryæ nieautoryzowane modyfikacje danych po ich podpisaniu.
\end{itemize}

Dwa dominuj¹ce standardy podpisu cyfrowego to RSA oraz DSA.

W niniejszym opracowaniu rozpatrywany jest standard RSA. Jego nazwa pochodzi od pierwszych liter nazwisk jego twórców: Rivest, Shamir i Adleman. RSA oparty jest o kryptografiê asymetryczn¹. Bezpieczeñstwo szyfrowania opiera siê na trudnoœci faktoryzacji du¿ych liczb z³o¿onych.
W podpisie cyfrowym opartym o algorytm RSA stosuje siê klucz prywatny do podpisywania oraz klucz publiczy do weryfikacji podpisu.

\subsubsection{Podpis cyfrowy z mediatorem}

Podpis elektroniczny z mediatorem to podpis cyfrowy, do którego z³o¿enia potrzebna jest dodadkowa zaufana strona zwana mediatorem. Klucz prywatny dzielony jest na czêœæ u¿ytkownika i czêœæ mediatora. Mediator bierze te¿ udzia³ przy generowaniu klucza prywatnego.

Generowanie klucza sk³ada siê z nastêpuj¹cych faz:

\begin{itemize}
	\item utworzenie przez dilera (generatora kluczy) pary kluczy, klucza prywatnego i publicznego,
	\item wys³anie do mediatora klucza publicznego oraz identyfikatora klucza,
	\item wygenerowanie przez mediator z modu³u klucza publicznego i identyfikatora klucza swojej czêœci klucza prywatnego i odes³ania go do dilera kluczy,
	\item obliczenie przez dilera kluczy czêœci prywatnej u¿ytkownika na podstawie czêœci klucza otrzymanego od mediatora i wygenerowanego w pierwszym punkcie klucza prywatnego
\end{itemize}

Z³o¿enie podpisu cyfrowego przy z pomoc¹ mediatora sk³ada siê z dwóch faz:

\begin{itemize}
	\item utworzenie czêœciowego podpisu po stronie u¿ytkownika, a nastêpnie wys³anie czêœciowego podpisu oraz podpisywanych danych do mediatora,
	\item podpisanie czêœciowego podpisu (finalizacja podpisu) przez stronê zaufan¹, czyli mediatora, a nastêpnie odes³anie podpisu do u¿ytkownika.
\end{itemize}

Weryfikacja podpisu odbywa identyczne jak w przypadku podpisu cyfrowego opartego o standardowy algorytm RSA w ca³oœci po stronie u¿ytkowniika.

\subsubsection{Model matematyczny i weryfikowanie podpisu}

\texttt{U¿ytkownik} posiadaj¹cy w systemie swój w³asny niepowtarzalny identyfikator \texttt{ID} oznaczony zostanie jako - \texttt{u}.

Dla ka¿dego \texttt{u} mo¿e zostaæ wygenerowana \texttt{para kluczy}:

\begin{itemize}
	\item \((d_u,N_u)\) --  \texttt{klucz prywatny},
	\item \((e_u,N_u)\) --  \texttt{klucz publiczny},
\end{itemize}

gdzie:

\begin{itemize}
	\item \((d_u)\) --  \texttt{eksponenta klucza prywatnego},
	\item \((e_u)\) --  \texttt{eksponenta klucza publicznego},
	\item \((N_u)\) --  \texttt{modu³} \texttt{klucza prywatnego} i  \texttt{klucza publicznego}.
\end{itemize}

\texttt{klucz prywatny} dzielony jest na dwie czêœci:

\begin{itemize}
	\item \((d_{K_u},N_u)\) -- \texttt{czêœæ prywatna klucza} strony finalizuj¹cej podpis \texttt{mediatora},
	\item \((d_{M_u},N_u)\) -- \texttt{czêœæ prywatna klucza} strony podpisuj¹cej \texttt{u¿ytkownika},
\end{itemize}

gdzie:

\begin{itemize}
	\item \(d_{K_u}\) -- \texttt{czêœæ prywatna eksponenty} strony podpisuj¹cej \texttt{u¿ykownika},
	\item \(d_{M_u}\) -- \texttt{czêœæ prywatna eksponenty} strony finalizuj¹cej podpis \texttt{mediatora}.
\end{itemize}

Eksponenty kluczy po podziale musz¹ spe³niaæ nastêpuj¹cy warunek:

\begin{itemize}
	\item \(d_u \equiv d_{K_u} + d_{M_u} \pmod{\varphi(N_u)} \),
\end{itemize}

gdzie:

\begin{itemize}
	\item \(\varphi\) -- funkcja nosz¹ca nazwisko Eulera przypisuje ka¿dej liczbie naturalnej liczbê liczb wzglêdnie z ni¹ pierwszych nie wiêkszych od niej samej.
\end{itemize}

\texttt{Plik} -- \texttt{p} podpisany cyfrowo przez \texttt{u¿ytkownika} -  \texttt{u} ma postaæ:

\begin{itemize}
	\item \((p,h(p)^{d_u}\pmod{N_u}\),
\end{itemize}

gdzie:

\begin{itemize}
	\item \(h(p)\) -- to skrót kryptograficzny \texttt{pliku} - \texttt{p} lub inaczej funkcja haszuj¹ca \texttt{pliku} - \texttt{p},
	\item \(h(p)^{d_u}\pmod{N_u}\) -- to skrót \texttt{pliku} - \texttt{p} podniesiony do potêgi \(d_u\) modulo \(N_u\)
	\item \(h(p)^{d_u}\pmod{N_u}\equiv h(p)^{d_{K_u}}\pmod{N_u} \times  h(p)^{d_{M_u}}\pmod{N_u}\).
\end{itemize}

Aby zweryfikowaæ \texttt{cyfrowo podpisany plik} w postaci \((p,h(p)^{d_u}\pmod{N_u}\), nale¿y dysponowaæ \texttt{kluczem publicznym} \((e_u,N_u)\) \texttt{u¿ytkownika} - \texttt{u}.
W przypadku gdy do danego \texttt{klucza publicznego} dostarczony jest \texttt{certyfikat} - \texttt{c} ma on postaæ:

\begin{itemize}
	\item \((e_u,N_u,c_u)\).
\end{itemize}

Certyfikat \(c_u\) ma postaæ:

\begin{itemize}
	\item \((u,e_u,N_u,h(u,e_u,N_u)^{d_c}\pmod{N_c},e_c,N_c)\),
\end{itemize}

gdzie:

\begin{itemize}
	\item \(h(u,e_u,N_u)^{d_c}\pmod{N_c}\) to skrót \texttt{klucza publicznego} \texttt{u¿ytkownika} oraz \texttt{identyfikatora u¿ytkownika} podniesiony do potêgi \texttt{eksponenty klucza prywatnego certyfikatu} modulo \texttt{modu³ klucza publicznego certyfikatu} \(N_c\),
\end{itemize}

\texttt{Klucz publiczny} i \texttt{klucz prywatny} \texttt{certyfikatu} - \texttt{c} przechowywany jest w \texttt{urzêdzie certyfikuj¹cym}:

\begin{itemize}
	\item \(U_c\).
\end{itemize}

Weryfikacja \texttt{podpisu} nastêpuje w dwóch etapach. Pierwszy etap to sprawdzenie autentycznoœci \texttt{certyfikatu}. Nastêpuje to poprzez obliczenie skrótu z pierwszych trzech wartoœci \texttt{certyfikatu} \((u,e_u,N_u)\). Otrzymany w ten sposób skrót \(h(u,e_u,N_u)\) porównywany jest z wartoœci¹ \((h(u,e_u,N_u)^{d_c})^{e_c}\pmod{N_c}\), która jest czwart¹ czêœci¹ \texttt{certyfikatu} podniesion¹ do potêgi \(e_c\) modulo \(N_c\).
Je¿eli zachodzi równoœæ:

\begin{itemize}
	\item  \(h(u,e_u,N_u) = (h(u,e_u,N_u)^{d_c})^{e_c}\pmod{N_c}\).
\end{itemize}

Oznacza to, ¿e \texttt{certyfikat} pomyœlnie przeszed³ próbê autoryzacji. Autentycznoœæ \texttt{certyfikatu} implikuje autentycznoœæ  \texttt{klucza publicznego u¿ytkownika} - \texttt{u}. Umo¿liwia to weryfikacjê podpisu samego \texttt{pliku}:

\begin{itemize}
	\item \((u,p,h(p)^{d_u}\pmod{N_u}\).
\end{itemize} 

Weryfikacja \texttt{pliku} - {p} nastêpuje poprzez obliczenie \(h(p)\), a nastêpnie porównanie tej wartoœci z \((h(p)^{d_u})^{e_u}\pmod{N_u}\), gdzie \((h(p)^{d_u})^{e_u}\pmod{N_u}\) to  \(h(p)^{d_u}\pmod{N_u}\) podniesione do potêgi eksponenty \(e_u\) autoryzowanego \texttt{klucza publicznego} \((e_u,N_u)\) modulo \(N_u\).
Je¿eli zachodzi równoœæ:

\begin{itemize}
	\item \(h(p) = (h(p)^{d_u})^{e_u}\pmod{N_u}\),
\end{itemize} 

oznacza to, ¿e proces weryfikacji zakoñczy³ siê pomyœlnie.
Je¿eli równoœæ ta nie zachodzi mo¿e oznaczaæ to ¿e:

\begin{itemize}
	\item \texttt{plik} - \texttt{p} od momentu podpisu zosta³ zmieniony,
	\item \texttt{plik} - \texttt{p} zosta³ podpisany przy pomocy innego \texttt{klucza prywatnego},
	\item \texttt{klucz publiczny} nie nale¿y do \texttt{u¿ytkownika}, który podpisa³ plik.
\end{itemize} 

\texttt{Plik} mo¿e byæ równierz zweryfikowany bez \texttt{certyfikatu klucza publicznego}.

\subsubsection{Generowanie i podzia³ kluczy}

\texttt{U¿ytkownik} - \texttt{u} chc¹cy podpisaæ \texttt{plik} - \texttt{p} musi posiadaæ \texttt{parê kluczy}, która sk³ada siê z \texttt{klucza prywatnego} bior¹cego udzia³ przy sk³adaniu podpisu, oraz z \texttt{klucza publicznego}, który jest niezbêdny do weryfikacji podpisu.
Za generowanie kluczy odpowiedzialne jest \texttt{centrum generowania kluczy} lub inaczej \texttt{generator kluczy}. Generowanie kluczy przebiega nastêpuj¹co:

\begin{itemize}
	\item Wybierz losowo dwie du¿e liczby pierwsze  \(p\) i  \(q\) przy uwzglêdnieniu nastêpuj¹cych warunków:
		\subitem - liczby powinny mieæ zbli¿on¹ d³ugoœæ w bitach, ale jednoczeœnie powinny byæ od siebie odleg³e wartoœciami;
		\subitem - d³ugoœæ bitowa wartoœci \(p \times q\) powinna byæ równa lub zbli¿ona do d³ugoœci bitowej obliczanego klucza.
	\item Oblicz \( N = p \times q\). N jest \texttt{modu³em klucza publicznego} i \texttt{klucza prywatnego}.
	\item Oblicz  \(\varphi(N) = \varphi(p) \times \varphi(q) = (p - 1) \times (q - 1) = N - (p + q - 1)\).
	\item Wybierz losowo \(e \in \{1,2,3,...,\varphi(N)\}\) wzglêdnie pierwsze z \(\varphi(N)\) tzn. najwiêkszy wspólny dzielnik \(NWD(e,\varphi(N)) = 1\). Sk³adnik \(e\) jest \texttt{eksponent¹ klucza publicznego}.
	\subitem Zaleca siê aby wartoœæ \(e\) mia³a krótk¹ d³ugoœæ bitow¹ oraz ma³¹ wagê hamminga, tzn. sumê wartoœci ró¿nych od 0 w danym alfabecie, w tym przypadku \(alfabet = \{0,1\}\) (rozpatrywany jest zapis bitowy liczby). Typow¹ stosowan¹ wartoœci¹ jest np. \(e = 2^{16} + 1 = 65,537\).
	\item Oblicz eksponentê klucza prywatnego \(d \in \{1,2,3,...,\varphi(N)\}\) tak¹ ¿e:
	\subitem - wartoœæ \(d \equiv e^{-1}\pmod{\varphi(N)}\), lub inaczej \(d \times e = 1\pmod{\varphi(N)}\), tzn. wartoœæ \(d\) jest odwrotnoœci¹ modularn¹  \(e\).
	\item Wartoœci \(p\), \(q\) oraz \(\varphi(N)\) powinny zostaæ niejawne, poniewa¿ mog¹ one s³u¿yæ do obliczenia \(d\).
\end{itemize}

Z tak obliczonych wartoœci tworzy siê nastêpnie:

\begin{itemize}
	\item \((d,N)\) -- \texttt{klucz prywatny},
	\item \((e,N)\) -- \texttt{klucz publiczny}.
\end{itemize}

Po obliczeniu \texttt{pary kluczy}, \texttt{klucz prywtny} dzielony jest na dwie czêœci:

\begin{itemize}
	\item \((d_{M},N)\) -- \texttt{czêœæ prywatna klucza} strony finalizuj¹cej podpis \texttt{mediatora},
	\item \((d_{K},N)\) -- \texttt{czêœæ prywatna klucza} strony podpisuj¹cej \texttt{u¿ytkownika}.
\end{itemize}

Klucze maj¹ wspólny modu³, lecz ró¿ne eksponenty. Eksponenty te musz¹ spe³niaæ nastêpuj¹cy warunek:

\begin{itemize}
	\item \(d \equiv d_{K} + d_{M} \pmod{\varphi(N)} \).
\end{itemize}

Podzia³ \texttt{klucz prywtnego} odbywa siê w dwóch etapach. Najpierw generowana jest \texttt{czêœæ prywatna klucza} strony finalizuj¹cej podpis \texttt{mediatora}. Proces ten przebiega nastêpuj¹co:

\begin{itemize}
	\item \texttt{Centrum generowania kluczy} wysy³a do \texttt{mediatora} wygenerowany \texttt{klucz publiczny} oraz \texttt{identyfikator} \texttt{ID} \texttt{u¿ytkownika} - \texttt{u}, dla którego zosta³y wygenerowane \texttt{klucze}.
	\item \texttt{Mediator} posiada swoj¹ w³asn¹ parê kluczy znan¹ tylko jemu. Swoim kluczem prywatnym \((d_{m},N_m)\) \texttt{mediator} podpisuje \texttt{ID} \texttt{u¿ytkownika}. Podpis ten jest postaci \(h(ID)^{d_m}\pmod{N_m}\).
	\subitem  Podpis \(h(ID)^{d_m}\pmod{N_m}\) s³u¿y jako ziarno dla \texttt{generatora liczb pseudolosowych}.
	\item \texttt{Generator liczb pseudolosowych} o ziarnie \(h(ID)^{d_m}\pmod{N_m}\) losuje liczbê pseudolosow¹ \(d_{M}\), tak¹ ¿e:
	\subitem - d³ugoœæ bitowa liczby \(d_{M}\) to suma d³ugoœci bitowej \texttt{modu³u klucza publicznego} \(N\) przes³anego przez \texttt{Centrum generowania kluczy} oraz wartoœci \texttt{delta}, gdzie \(delta \in \{80...128\}\).
	\subitem - D³ugoœæ bitowa \(N\) mo¿e byæ obliczona jako \(floor(\log_2(N))+1\).
\end{itemize}

Liczby \((d_{M},N)\) tworz¹ \texttt{czêœæ prywatna klucza} strony finalizuj¹cej podpis \texttt{mediatora}. Liczba \(d_M\) wygenerowana w \texttt{mediatorze} odsy³ana jest nastêpnie do \texttt{centrum generowania kluczy}, gdzie na jej podstawie obliczana jest \texttt{czêœæ prywatna klucza} strony podpisuj¹cej \texttt{u¿ytkownika}. Odbywa siê to w nastêpuj¹cy sposób:

\begin{itemize}
	\item \(d_K = d - d_M \pmod{\varphi(N)}\).
\end{itemize}

Liczba \(d_K\) wraz z modu³em \(N\) tworz¹ \texttt{czêœæ prywatna klucza} strony podpisuj¹cej \texttt{u¿ytkownika} \((d_K,N)\).

\subsubsection{Podpis pliku}

\texttt{U¿ytkownik} - \texttt{u} ch¹cy podpisaæ \texttt{plik} - \texttt{p} oblicza skrót pliku \(h(p)\), a nastêpnie podnosi go do potêgi \(d_{K_u}\) modulo \(N_u\). Tak czêœciowo podpisany plik ma postaæ:

\begin{itemize}
	\item \(h(p)^{d_{K_u}}\pmod{N_u}\).
\end{itemize}

\texttt{U¿ytkownik} - \texttt{u} wysy³a do mediatora skrót \texttt{pliku} - \texttt{p} \(h(p)\) oraz czêœciowy podpis \(h(p)^{d_{K_u}}\pmod{N_u}\).

Mediator przy pomocy swojej czêœci klucza prywatnego podpisuje otrzymany skrót \(h(p)\) otrzymuj¹c w ten sposób \(h(p)^{d_{_u}}\pmod{N_u}\), a nastêpnie mno¿y go z otrzymanym podpisem modulo \(N_u\). Po takiej operacji podpis jest kompletny i ma postaæ:

\begin{itemize}
	\item \(h(p)^{d_{K_u}}\pmod{N_u} \times  h(p)^{d_{M_u}}\pmod{N_u} = h(p)^{d_u}\pmod{N_u}\).
\end{itemize}

Podpis taki odsy³any jest do \texttt{u¿ytkownika} - \texttt{u}, który mo¿e do³¹czyæ go do \texttt{pliku} - \texttt{p}. Otrzymuj¹c podpisany plik w postaci:

\begin{itemize}
	\item \((p,h(p)^{d_u}\pmod{N_u})\).
\end{itemize}

\newpage

\section{Projekt systemu}
W niniejszym rozdziale zosta³ przedstawiony projekt systemu. W pierwszym podrozdziale przedstawiona zosta³a komunikacja oraz interakcje pomiêdzy poszczególnymi elementami systemu. W kolejnych podrozdzia³ach przedstawione zosta³y projekty poszczególnych elementów systemu: \texttt{serwera dostêpowego},  \texttt{mediatora}, \texttt{klienta} oraz \texttt{klienta administratorskiego}.

\subsection{U¿ytkownicy systemu}

\texttt{U¿ytkownik} w systemie mo¿e byæ przypisany do nastêpuj¹cych \texttt{ról}.

\begin{itemize}
	\item \texttt{U¿ytkownik standardowy} - posiada on standardow¹ funkcjonalnoœæ, przedstawion¹ w diagramie przypadku u¿ycia z wyj¹tkiem, z wy³¹czeniem dzia³añ administracyjnych, a wiêc zarz¹dzaniem \texttt{u¿ytkownikami} systemu.
	\item \texttt{Administrator} - posiada on funkcjonalnoœæ u¿ytkownika standardowego, a dodadkowo mo¿liwoœæ zarz¹dzania \texttt{u¿ytkownikami} systemu. \texttt{Administrator} ma mo¿liwoœæ logowania siê do systemu za poœrednictwem \texttt{aplikcji administratorskiej}.
\end{itemize}

\subsection{Projekt komunikacji pomiêdzy wêz³ami}

W podrozdziale tym przedstawiony zosta³ przebieg komunikacji pomiêdzy elementami systemu dla wybranych przypadków u¿ycia. Komunikacja w systemie odbywa siê za poœrednictwem web serwisów typu REST. W przypadku \texttt{logowania}, \texttt{wylogowywania} oraz \texttt{wysy³ania wiadomoœci} s¹ to zapytania synchroniczne. W przypadku \texttt{odbioru wiadomoœci}, \texttt{generowania klucza} oraz \texttt{podpisywania pliku} s¹ to zapytania asynchroniczne typu Long Pooling.
\texttt{Klient administratorski} u¿ywa zapytania asynchronicznego do pobrania listy u¿ytkowników. W przypadku gdy jakiœ wêze³ system jest niedostêpny \texttt{klient} systemu dostaje komunikat o b³êdzie.
W przypadku ³¹czenia siê \texttt{klientów} z sieci Internet, komunikacja pomiêdzy elementami systemu powinna byæ szyfrowana. Konfiguracja szyfrowania odbywa siê na serwerze Javy EE. Zaleca siê w³¹czenie szyfrowania za pomoc¹ protoko³u TLS. Nale¿y wtedy dostarczyæ \texttt{certyfikat serwera} lub taki wygenerowaæ.
Komunikacja wêz³ami odbywa siê za pomoc¹ obiektów transportowych przedstawionych na rysunku \ref{classTO1}. Obiekty przed wys³aniem serializowane s¹ do formatu JSON i w takim formacie przesy³ane. Nastêpnie po odbiorze deserializowane z powrotem do obiektów transportowych.

\newpage

\begin{figure}[h!]
\begin{center}
\includegraphics[width=0.8\textwidth]{classTO.png}
\end{center}
\caption{Diagram klas - obiekty transportowe.} \label{classTO1}
\end{figure}


\newpage

\subsubsection{Logowanie}

Logowanie to proces, który inicjuje \texttt{klient} systemu. Do zalogowania siê do systemu niezbêda jest znajomoœæ \texttt{loginu}, \texttt{has³a} oraz \texttt{klucza serwisowego}. Wszystkie te elementy dostarczane s¹ przez \texttt{administratora} po za³o¿eniu konta \texttt{u¿ytkownika} w systemie.
\texttt{Klient} wysy³a do \texttt{serwera dostêpowego} ¿¹danie zalogowania, a wraz z nim \texttt{u¿ytkownika}, \texttt{has³o} i \texttt{klucz serwisowy}, nastêpnie po pomyœlnym zautoryzowaniu \texttt{u¿ytkownika} na \texttt{serwerze dostêpowym} generowany jest unikalny \texttt{token}. \texttt{Token} dodawany jest do \texttt{listy tokenów}, a nastêpnie zwracany jest do \texttt{klienta}. Po otrzymaniu \texttt{tokena} w odpowiedzi REST \texttt{klient} zapisuje go. Od tego momentu \texttt{klient} jest zalogowany, a ka¿de nastêpne ¿¹danie, a¿ do wylogowania odbywa siê przy pomocy \texttt{klucza serwisowego} oraz \texttt{tokena} bez udzia³u \texttt{loginu} i \texttt{has³a}. Przy ¿adaniu wylogowania z systemu \texttt{serwer dostêpowy} usuwa z \texttt{token} z \texttt{listy tokenów}.
Diagramy na rysunkach \ref{logInActivity1} i \ref{LogIn1} przedstawij¹ proces logowania.

\newpage

\textbf{Diagram aktywnoœci dla logowania}\\

\begin{figure}[h!]
\begin{center}
\includegraphics[width=0.8\textwidth]{logInActivity.pdf}
\end{center}
\caption{Logowanie do systemu - diagram aktywnoœci.} \label{logInActivity1}
\end{figure}

\newpage

\textbf{Diagram sekwencji dla logowania}\\

\begin{figure}[h!]
\begin{center}
\includegraphics[width=0.7\textwidth]{LogIn.pdf}
\end{center}
\caption{Logowanie do systemu - diagram sekwencji.} \label{LogIn1}
\end{figure}

\newpage

\subsubsection{Wysy³anie wiadomoœci}

\texttt{U¿ytkownik} ma mo¿liwoœæ wysy³ania wiadomoœci tekstowych do innych \texttt{u¿ytkowników} systemu. Aby wys³aæ wiadomoœæ z \texttt{klienta} nale¿y byæ zalogowanym do systemu. \texttt{Klient} wysy³a ¿¹danie REST do \texttt{serwera dostêpowego}, w treœci którego znajduje siê \texttt{wiadomoœæ}, a w nag³ówku \texttt{klucz serwisowy} oraz \texttt{token}. \texttt{Serwer dostêpowy} nastêpnie autoryzuje \texttt{u¿ytkownika} oraz sprawdza \texttt{listê nas³uchuj¹cych} \texttt{u¿ytkowników}. Je¿eli adresat wiadomoœci znajduje siê na tej liœcie to \texttt{serwer dostêpowy} przekazuje mu wiadomoœæ od nadawcy. Je¿eli u¿ytkownika nie ma na liœcie, to wiadomoœæ dodawana jest do \texttt{listy wiadomoœci} i bêdzie tam a¿ do chwili zalogowania siê adresata wiadomoœci do systemu, po czym zostanie mu przekazana. Na rysunkach \ref{sendMessageActivity1} i \ref{sendMessage1} zosta³ przedstawiony proces, który zachodzi po wys³aniu wiadomoœci z aplikacji \texttt{klienta}.

\newpage

\textbf{Diagram aktywnoœci dla wysy³ania wiadomoœci}\\

\begin{figure}[h!]
\begin{center}
\includegraphics[width=0.8\textwidth]{sendMessageActivity.pdf}
\end{center}
\caption{Wysy³anie wiadomoœci  - diagram aktywnoœci.} \label{sendMessageActivity1}
\end{figure}

\newpage

\textbf{Diagram sekwencji dla wysy³ania wiadomoœci}\\

\begin{figure}[h!]
\begin{center}
\includegraphics[width=0.7\textwidth]{sendMessage.pdf}
\end{center}
\caption{Wysy³anie wiadomoœci  - diagram sekwencji.} \label{sendMessage1}
\end{figure}

\newpage

\subsubsection{Odbiór wiadomoœci}

Odbiór wiadomoœci odbywa siê równie¿ przy pomocy asynchronicznego zapytania REST. Po zalogowianiu \texttt{klient} wysy³a do \texttt{serwera dostêpowego} ¿¹danie odbioru \texttt{wiadomoœci} z nag³ówkiem zawieraj¹cym \texttt{klucz serwisowy} i \texttt{token}. Po pomyœlnej autoryzacji \texttt{serwer dotêpowy} sprawdza \texttt{listê wiadomoœci} w poszukiwaniu \texttt{wiadomoœci}, której adresat jest \texttt{u¿ytkownikiem} wysy³aj¹cym ¿¹danie. W przypadku znalezienia takiej wiadomoœci zostaje ona do³¹czona do odpowiedzi i jest zwracana do\texttt{klienta}. W przypadku, gdy na \texttt{liœcie wiadomoœci} nie ma ¿adnej wiadomoœci do \texttt{u¿ytkownika}, to ¿¹danie zapisywane jest na \texttt{liœcie nas³uchuj¹cych} i znajduje siê tam a¿ do chwili pojawienia siê \texttt{wiadomoœci} do \texttt{u¿ytkownika}. Ka¿de ¿¹danie wysy³aj¹ce wiadomoœæ sprawdza najpierw \texttt{listê nas³uchuj¹cych}. W chwili pojawienia siê na \texttt{serwerze dostêpowym} nowego ¿¹dania wys³ania \texttt{wiadomoœci} z \texttt{wiadomoœci¹} do \texttt{u¿ytkownika}, którego zapytanie znajduje siê na \texttt{liœcie nas³uchuj¹cych}, \texttt{wiadomoœæ} zostaje do³¹czona do ¿¹dania oczekuj¹cego, a ¿¹danie zostaje usuniête z \texttt{listy nas³uchuj¹cych} i jest odsy³ane do \texttt{klienta} jako odpowiedŸ na ¿¹dnaie asynchroniczne. Aplikacja \texttt{klient} po otrzymaniu odpowiedzi wyœwietla na \texttt{liœcie kontatków} obok \texttt{kontatku}, który jest adresatem \texttt{wiadomoœci} informacjê o nowej \texttt{wiadomoœci}. Proces w aplikacji \texttt{klient} do odbioru \texttt{wiadomoœci} uruchamiany jest jako osobny w¹tek w tle. Proces ten dzia³a w pêtli tak, ¿e po wysy³aniu ¿¹dania odbioru i otrzymaniu odpowiedzi wysy³a ponowne ¿¹danie odbioru \texttt{wiadomoœci}. Na rysunkach \ref{reciveMessageActivity1} i \ref{reciveMessage1} przedstawiony zosta³ proces odbioru wiadomoœci.

\newpage

\textbf{Diagram aktywnoœci dla odbioru wiadomoœci}\\

\begin{figure}[h!]
\begin{center}
\includegraphics[width=0.7\textwidth]{reciveMessageActivity.pdf}
\end{center}
\caption{Odbiór wiadomoœci  - diagram aktywnoœci.} \label{reciveMessageActivity1}
\end{figure}

\newpage

\textbf{Diagram sekwencji dla odbioru wiadomoœci}\\

\begin{figure}[h!]
\begin{center}
\includegraphics[width=0.7\textwidth]{reciveMessage.pdf}
\end{center}
\caption{Odbiór wiadomoœci  - diagram sekwencji.} \label{reciveMessage1}
\end{figure}

\newpage

\subsubsection{Generowanie pary kluczy}

Proces generowania kluczy odbywa siê w oparciu o model matematyczny przedstawiony w rozdziale 3. Nowe klucze generowane s¹ na ¿adanie \texttt{u¿ytkownika}. W aplikacji \texttt{klienckiej} ¿¹danie generowania \texttt{pary kluczy} to jedyne ¿¹danie oprócz logowania, które w celu dodadkowego zabezpieczenia, wymaga podania \texttt{loginu} i \texttt{has³a}. ¯¹danie generowania kluczy wysy³ane jest do \texttt{serwera dostêpowego}. Serwer po pomyœlnej autoryzacji \texttt{u¿ytkownika} generuje now¹ parê kluczy: \texttt{klucz publiczny} oraz \texttt{klucz prywatny}. \texttt{Klucz publiczny} oraz \texttt{klucz serwisowy} wysy³any jest nastêpnie do \texttt{mediatora}. \texttt{Mediator} na podstawie d³ugoœci bitowej \texttt{klucza publicznego}, w³asnego \texttt{klucza prywatnego} oraz wartoœci losowej generuje w oparciu o swój algorytm \texttt{prywatny klucz finalizuj¹cy}. Mediator zapisuje klucz publiczny \texttt{u¿ytkownika} oraz \texttt{prywatny klucz finalizuj¹cy}, nastêpnie \texttt{prywatny klucz finalizuj¹cy} odsy³any jest do \texttt{serwera dostêpowego}. Serwer na podstawie wczeœniej wygenerowanego \texttt{klucza prywatnego} oraz \texttt{prywatnego klucza finalizuj¹cego} oblicza \texttt{prywatny klucz u¿ytkownika}. \texttt{Para kluczy} sk³adaj¹ca siê z \texttt{prywatnego klucz u¿ytkownika} oraz wczeœniej wygenerowanego {klucza publicznego} odsy³ana jest do \texttt{klienta} jako odpowiedŸ na asynchroniczne zapytanie REST. \texttt{Klient} po zakoñczeniu ¿¹dania zapisuje swoj¹ \texttt{parê kluczy} do plików. W przypadku generowania ponownie \texttt{pary kluczy}, stara para zostaje nadpisana na \texttt{mediatorze} oraz w aplikacji \texttt{klienta}. W takim przypadku, nale¿y zabezpieczyæ istniej¹cy plik zawieraj¹cy \texttt{klucz publiczny} w celu póŸniejszej weryfikacji \texttt{plików} podpisanych przy pomocy odpowiadaj¹cemu mu \texttt{kluczowi prywatnemu}. Rysunki \ref{generateKeyActivity1} i \ref{generateKey1} przedstawiaj¹ proces generowania pary kluczy.

\newpage

\textbf{Diagram aktywnoœci dla generowania pary kluczy}\\

\begin{figure}[h!]
\begin{center}
\includegraphics[width=0.8\textwidth]{generateKeyActivity.pdf}
\end{center}
\caption{Diagram aktywnoœci - generowanie pary kluczy.} \label{generateKeyActivity1}
\end{figure}

\newpage

\textbf{Diagram sekwencji dla generowania pary kluczy}\\

\begin{figure}[h!]
\begin{center}
\includegraphics[width=0.7\textwidth]{generateKey.pdf}
\end{center}
\caption{Diagram sekwencji - generowanie pary kluczy.} \label{generateKey1}
\end{figure}

\newpage

\subsubsection{Podpisywanie pliku}

Proces podpisywania pliku równie¿ odbywa siê w oparciu o model matematyczny przedstawiony w rozdziale 3. Aby podpisaæ plik \texttt{u¿ytkownik} powinien posiadaæ wczeœniej wygenerowan¹ \texttt{parê kluczy}. Nastêpnie plik do podpisu powinien zostaæ wczytany w aplikacji \texttt{klient}. Z za³adowanego wczeœniej \texttt{pliku} zostaje obliczony \texttt{skrót} kryptograficzny \texttt{SHA512}. \texttt{Skrót} ten jest nastêpnie podpisywany \texttt{kluczem prywatnym u¿ytkownika}. Czêœciowo podpisany \texttt{plik} oraz jego \texttt{skrót} wysy³ane s¹ w ¿¹daniu podpisu do \texttt{serwera dostêpowego}. Nag³ówek ¿¹dania zawiera \texttt{klucz serwisowy} i \texttt{token}. \texttt{Serwera dostêpowy} po pomyœlnym zautoryzowaniu \texttt{u¿ytkownika} przesy³a do \texttt{mediatora} otrzymany \texttt{podpis} i \texttt{skrót} oraz \texttt{klucz serwisowy}  \texttt{u¿ytkownika}. \texttt{Mediator} podpisuje otrzymany \texttt{skrót} przy pomocy \texttt{prywatnego klucza finalizuj¹cego}, a nastêpnie sk³ada go z podpisem dokonanym przez \texttt{klienta}. Z³o¿ony podpis odsy³any jest jako odpowiedŸ asynchroniczna do \texttt{serwera dostêpowego}, który odsy³a go do  \texttt{klienta}. \texttt{Podpis} zapisywany jest automatycznie do pliku. Proces podpisywania \texttt{pliku} zosta³ przedstawiony na rysunkach \ref{signFileActivity1} i \ref{signFile1}

\newpage

\textbf{Diagram aktywnoœci dla podpisywania pliku}\\

\begin{figure}[h!]
\begin{center}
\includegraphics[width=0.8\textwidth]{signFileActivity.pdf}
\end{center}
\caption{Diagram aktywnoœci - podpisywanie pliku.} \label{signFileActivity1}
\end{figure}

\newpage

\textbf{Diagram sekwencji dla podpisywania pliku}\\

\begin{figure}[h!]
\begin{center}
\includegraphics[width=0.7\textwidth]{signFile.pdf}
\end{center}
\caption{Diagram sekwencji - podpisywanie pliku.} \label{signFile1}
\end{figure}

\newpage

\subsubsection{Weryfikacja podpisu}

Aby zweryfikowaæ podpisany \texttt{plik} nale¿y wczytaæ go w aplikacji \texttt{klienckiej}, nastêpnie nale¿y wczytaæ \texttt{podpis} pliku oraz \texttt{klucz publiczny} nale¿¹cy do \texttt{u¿ytkownika}, który ten plik podpisa³. Weryfikacja nastêpuje wtedy w ca³oœci po stronie klienta. Proces ten zosta³ dok³adniej przedstawiony w projekcie aplikacji klienta.

\newpage


\subsection{Projekt serwera dostêpowego}

\subsubsection{Komponenty serwera dostêpowego}

\begin{figure}[h!]
\begin{center}
\includegraphics[width=0.8\textwidth]{registrationServer.pdf}
\end{center}
\caption{Interakcje miêdzy komponentami serwera dostêpowego.} \label{registrationServer1}
\end{figure}

\newpage

\subsubsection{Diagram klas}

\begin{figure}[h!]
\begin{center}
\includegraphics[width=0.9\textwidth]{classRegistration.png}
\end{center}
\caption{Uproszczony diagram klas serwera dostêpowego.} \label{classRegistration1}
\end{figure}

\newpage

\begin{figure}[h!]
\begin{center}
\includegraphics[width=0.9\textwidth]{classRegistrationFull.png}
\end{center}
\caption{Diagram wybranych klas serwera dostêpowego.} \label{classRegistrationFull1}
\end{figure}

\subsubsection{Diagramy sekwencji}

TODO diagram sekwencji dla wybranej metody

\newpage

\subsection{Projekt serwera mediatora}

\subsubsection{Komponenty mediatora}

\begin{figure}[h!]
\begin{center}
\includegraphics[width=0.8\textwidth]{mediator.pdf}
\end{center}
\caption{Interakcje miêdzy komponentami mediatora.} \label{mediator1}
\end{figure}

\newpage

\subsubsection{Diagram klas}

\begin{figure}[h!]
\begin{center}
\includegraphics[width=0.9\textwidth]{classMediator.png}
\end{center}
\caption{Diagram wybranych klas mediatora.} \label{classMediator1}
\end{figure}

\newpage

\subsection{Projekt aplikacji klienta}

\subsubsection{Komponenty klienta}

\begin{figure}[h!]
\begin{center}
\includegraphics[width=0.8\textwidth]{client.pdf}
\end{center}
\caption{Interakcje miêdzy komponentami klienta.} \label{client1}
\end{figure}

\newpage

\subsubsection{Diagram klas}

\begin{figure}[h!]
\begin{center}
\includegraphics[width=0.9\textwidth]{classClient.png}
\end{center}
\caption{Uproszczony diagram klas klienta.} \label{classClient1}
\end{figure}

\newpage

\begin{figure}[h!]
\begin{center}
\includegraphics[width=0.8\textwidth]{classClientFULL.png}
\end{center}
\caption{Diagram wybranych klas klienta.} \label{classClientFull1}
\end{figure}

\newpage

\section{Implementacja elementów systemu}

Do zaimplementowana elementów systemu u¿yto zintegrowanego œrodowiska programistycznego \texttt{Eclipse Java EE Mars 4.5.1}. System sk³ada siê z nastêpuj¹cych projektów:

\begin{itemize}
	\item \texttt{common} -- projekt zawieraj¹cy wspólne klasy, klasy niektóre klasy pomocnicze i obiekty transportowe,
	\item \texttt{integration-test} -- projekt zawieraj¹cy testy integracyjne,
	\item \texttt{docs} -- projekt zawieraj¹cy dokumentacjê w formacie \LaTeX, projekty diagramów klass, projekty Microsoft Visio oraz screeny z testów,
	\item \texttt{java-client} -- projekt zawieraj¹cy \texttt{aplikacjê klienta},
	\item \texttt{java-client-admin} -- projekt zawieraj¹cy \texttt{apliikacjê administratora},
	\item \texttt{mediator-server} -- projekt zawieraj¹cy aplikacjê \texttt{mediatora},
	\item \texttt{registration-server} -- projekt zawieraj¹cy aplikacjê \texttt{serwera dostêpowego},
	\item \texttt{security-systems-ee} -- projekt ³¹cz¹cy wszystkie projekty, u³atwiaj¹cy budowanie systemu.
\end{itemize}

Przy rozwijaniu projektu u¿yty zosta³ system kontroli wersji \texttt{Git}. Wszystkie kody Ÿród³owe s¹ dostêpna pod adresem:
\begin{itemize}
	\item \url{https://github.com/Michal-Lange/SecureSystemsEE}.
\end{itemize}
Projekty zosta³y budowane przy u¿yciu narzêdzia \texttt{Apache Maven 3.3.3}. Konfiguracja projektów znajduje siê w plikach \texttt{pom}. W plikach \texttt{pom} zdefiniowane zosta³y zale¿noœci pomiêdzy projektami, zawarta konfiguracja projektów, okreœlone niezbêdne biblioteki. Na listingu \ref{lst:pomCommon1} przedstawiony zosta³ przyk³adowy plik \texttt{pom} dla projektu \texttt{common}.

¯ród³a wiêkszoœci projektów podzielone s¹ na 4 katalogi:

\begin{itemize}
	\item \texttt{src/main/java} -- katalog zawieraj¹cy ¿ród³a, g³ównie pliki z rozszerzeniem java,
	\item \texttt{scr/test/java} -- katalog zawieraj¹cy testy jednostkowe dla danego projetku,
	\item \texttt{src/main/resources} -- katalog zawieraj¹cy zasoby aplikacji,
	\item \texttt{scr/test/resources} -- katalog zawieraj¹cy zasoby dla testów.
\end{itemize}

\newpage

\begin{lstlisting}[label={lst:pomCommon1}, language=xml, frame=lines, numberstyle=\tiny, stepnumber=1, caption=Plik \texttt{pom.xml} dla projektu \texttt{common}., firstnumber=1]
<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
	xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
	<modelVersion>4.0.0</modelVersion>
	<groupId>net.ddns.falcoboss.common</groupId>
	<artifactId>common</artifactId>
	<name>Common</name>
	<description>Common Classes</description>
	<properties>
		<project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>
		<project.reporting.outputEncoding>UTF-8</project.reporting.outputEncoding>
	</properties>
	<dependencies>
		<dependency>
			<groupId>junit</groupId>
			<artifactId>junit</artifactId>
			<version>4.12</version>
		</dependency>
	</dependencies>
	<build>
		<plugins>
			<plugin>
				<groupId>org.apache.maven.plugins</groupId>
				<artifactId>maven-compiler-plugin</artifactId>
				<version>3.1</version>
				<configuration>
					<source>1.8</source>
					<target>1.8</target>
				</configuration>
			</plugin>
		</plugins>
	</build>
	<parent>
		<groupId>net.ddns.falcoboss.enterprise.systems.ee</groupId>
		<artifactId>security-systems-ee</artifactId>
		<version>1.0-SNAPSHOT</version>
		<relativePath>../SecuritySystemsEE</relativePath>
	</parent>
</project>
\end{lstlisting}

\newpage

\subsection{Implementacja serwera dostêpowego}

W tym podrozdizle 

\subsubsection{Realizacja modu³u ...}
\subsubsection{Realizacja filtrów zapytañ}

\begin{lstlisting}[label={lst:requestFilter1}, language=Java, frame=lines, numberstyle=\tiny, stepnumber=1, caption=RequestFilter.java., firstnumber=1]
package net.ddns.falcoboss.registrationserver.security;
import java.io.IOException;
import java.util.logging.Logger;
import javax.ejb.EJB;
import javax.ejb.Local;
import javax.ejb.Stateless;
import javax.ws.rs.container.ContainerRequestContext;
import javax.ws.rs.container.ContainerRequestFilter;
import javax.ws.rs.container.PreMatching;
import javax.ws.rs.core.Response;
import javax.ws.rs.ext.Provider;

import net.ddns.falcoboss.common.HTTPHeaderNames;
 
@Provider
@PreMatching
@Local
@Stateless
public class RequestFilter implements ContainerRequestFilter {
 
    private final static Logger log = 
Logger.getLogger(RequestFilter.class.getName());
 
    @EJB
    AuthenticatorBean authenticatorBean;
    
    @Override
    public void filter(ContainerRequestContext requestCtx) throws IOException {
    	  String path = requestCtx.getUriInfo().getPath();
        log.info( "Filtering request path: " + path );
        String serviceKey = 
requestCtx.getHeaderString(HTTPHeaderNames.SERVICE_KEY);

        if (!authenticatorBean.isServiceKeyValid(serviceKey)) {
            requestCtx.abortWith(Response.status(
Response.Status.UNAUTHORIZED).build());
            return;
        }
 
        if (!path.startsWith( "service/login/" )) {
            String authToken = 
requestCtx.getHeaderString(HTTPHeaderNames.AUTH_TOKEN);
            if (!authenticatorBean.isAuthTokenValid(serviceKey, authToken)) {
                requestCtx.abortWith(Response.status(
Response.Status.UNAUTHORIZED).build());
            }
        }
    }
}
\end{lstlisting}

\newpage

\subsubsection{Filtr odpowiedzi}

\begin{lstlisting}[label={lst:responseFilter1}, language=Java, frame=lines, numberstyle=\tiny, stepnumber=1, caption=RequestFilter.java., firstnumber=1]
package net.ddns.falcoboss.registrationserver.security;
import java.io.IOException;
import java.util.logging.Logger;
import javax.ws.rs.container.ContainerRequestContext;
import javax.ws.rs.container.ContainerResponseContext;
import javax.ws.rs.container.ContainerResponseFilter;
import javax.ws.rs.container.PreMatching;
import javax.ws.rs.ext.Provider;
import net.ddns.falcoboss.common.HTTPHeaderNames;

@Provider
@PreMatching
public class ResponseFilter implements ContainerResponseFilter {
 
    private final static Logger log = Logger.getLogger(ResponseFilter.class.getName());
 
    @Override
    public void filter(ContainerRequestContext requestContext, 
        ContainerResponseContext responseContext) throws IOException {
 
        log.info("Filtering REST Response");
 
        responseContext.getHeaders().add("Access-Control-Allow-Origin", "*");
        responseContext.getHeaders().add("Access-Control-Allow-Credentials", "true");
        responseContext.getHeaders().add("Access-Control-Allow-Methods", "GET, POST, DELETE, PUT");
        responseContext.getHeaders().add("Access-Control-Allow-Headers", HTTPHeaderNames.
        SERVICE_KEY + ", " + HTTPHeaderNames.AUTH_TOKEN);
    }
}
\end{lstlisting}

\newpage

\section{Testowanie i ocena jakoœci systemu}

\subsection{Instalowanie i konfiguracja systemu}

\subsubsection{Œrodowisko testowe}

Œrodowisko testowe sk³ada siê z 3 komputerów.

\begin{itemize}
  \item \texttt{Rasspbery PI 2}, 4-rdzeniowy procesor ARM Cortex-A7 900MHz, 1GB RAM;
  \item \texttt{Lenovo T540}, 4-rdzeniowy procesor i7-4700MQ 2,4GHz, 8GB RAM;
  \item \texttt{Lenovo Y550}, 2-rdzeniowy procesor Core 2 Duo T6500 2,1GHZ, 4GB RAM;
\end{itemize}

\texttt{Mediator} uruchomiony zosta³ na \texttt{Rasspbery PI2} z baz danych \texttt{MySql 5.7}.
\texttt{Serwer dostêpowy} uruchomiony zosta³ na \texttt{Lenovo T540} z baz danych \texttt{Oracle 11g}.
\texttt{Klient} i \texttt{Klient administrator} dzia³aj na \texttt{Lenovo Y550}.
\texttt{Mediator} i \texttt{Serwer dostêpowy} uruchamiane s¹ wewn¹trz kontenerów hostowanych przez serwer aplikacji \texttt{Glassfiash 4.1.1 Full Platform}.
Na wszystkich komputerach zainstalowana zosta³a  Maszyna wirtualna Javy \texttt{JVM 1.8.0\_60-b27}.
Komputery po³¹czone s¹ za pomoc¹ sieci LAN o maksymalnej przepustowoœci 100MB/s.
Domyœlna biblioteka serwera \texttt{Glassfiash 4.1.1 Full Platform}  odpowiadaj¹ca za persystencje obiektów \texttt{EclipseLink 2.6.1-RC1} zawiera b³¹d i uniemo¿liwia poprawne dzia³anie z baz¹ danych, dlatego wymagana jest aktualizacja biblioteki do wersji 2.6.2.
Na rysunku \ref{testEnviroment1} przedstawiona zosta³a konfiguracja testowa systemu.

\newpage

\begin{figure}[h!]
\begin{center}
\includegraphics[width=0.7\textwidth]{testEnviroment.pdf}
\end{center}
\caption{Œrodowisko testowe.} \label{testEnviroment1}
\end{figure}

\newpage

Przy wdra¿aniu systemu w œrodowisku produkcyjnym w celu zapewnienia wydajnoœci oraz bezpieczeñstwa nale¿y spe³niæ dodadkowe warunki:
\begin{itemize}
	\item serwery i odpowiadaj¹ce im bazy danych powinny znajdowaæ siê na tym samym hoœcie;
	\item \texttt{mediator} powinien znajdowaæ siê w bezpiecznej sieci wewnêtrznej i byæ nieosi¹galny z zewn¹trz, a osi¹galny jedynie dla \texttt{serwera dostêpowego};
	\item dla \texttt{serwera dostêpowego} powinien zostaæ utworzony \texttt{certyfikat}, a zapytania powinny byæ obs³ugiwane jedynie bezpiecznym kana³em za pomoc¹ protoko³u \texttt{HTTPS};
	\item \texttt{serwera dostêpowy} powinien byæ osi¹galny z zewn¹trz np. sieci internet, ale jednoczeœnie byæ chroniony firewallem, powinien znajdowaæ siê w tzw. strefie zdemilitaryzowanej (DMZ).
\end{itemize}

\begin{figure}[h!]
\begin{center}
\includegraphics[width=0.7\textwidth]{prodEnviroment.pdf}
\end{center}
\caption{Przyk³adowe œrodowisko produkcyjne.} \label{prodEnviroment1}
\end{figure}

\newpage

\subsubsection{przygotowanie bazy danych}

Na zainstalowan¹ bazê danych nale¿y siê zalogowaæ, utworzyæ \texttt{u¿ytkownika} oraz dodaæ mu prawa dostêpowe do bazy. Na listingu \ref{lst:database1} przedstawio utworzenie \texttt{u¿ytkownika} dla \texttt{serwera dostêpowego} oraz nadanie mu odpowiednich praw. Analogicznie nale¿y utworzyæ \texttt{u¿ytkownika} dla \text{mediatora}.

\begin{lstlisting}[label={lst:database1}, language=sql, frame=lines, numberstyle=\tiny, stepnumber=1, caption=Tworzenie bazy danych i u¿ytkownika bazy danych, firstnumber=1]
-- po³¹czenie z systemem bazodanowym jako root
mysql --host=192.168.1.20 --user=root -p

-- usuwanie bazy danych je¿eli istnieje
mysql> DROP DATABASE IF EXISTS secstorage;

-- tworzenie bazy danych
mysql> CREATE DATABASE secstorage;

-- polaczenie z utworzon¹ baz¹ danych
mysal> use secstorage; 

-- usuwanie u¿ytkownika
mysql> DROP USER 'mainStorage'@'localhost';

-- utworzenie u¿ytkownika
mysql> CREATE USER 'mainStorage'@'localhost' IDENTIFIED BY 'registrationServer1';

-- nadanie utworzonemu u¿ytkownikowi wszystkich praw do utworzonej bazy
mysql> GRANT ALL PRIVILEGES ON *.* TO 'mainStorage'@'localhost';
\end{lstlisting}

\subsubsection{Konfiguracja serwera Java EE}

Po³¹czenie do bazy danych konfigurowane jest w serwerze Java EE i dodawane do puli po³¹czeñ. Udostêpnienie po³¹czenia dla aplikacji nastêpuje poprzez zdefiniowanie zasobu dla puli. Do poprawnego dzia³ania systemu nale¿y utworzyæ pule oraz zasoby dla bazy danych \texttt{serwera dostêpowego} i \texttt{mediatora}. Na listingu \ref{lst:jdbcResource1} Przedstawione zosta³o utworzenie puli i zasobu dla \texttt{serwera dostêpowego}. Analogiczn¹ konfiguracjê nale¿y przeprowadziæ dla \texttt{mediatora}.

\begin{lstlisting}[label={lst:jdbcResource1}, language=bash, frame=lines, numberstyle=\tiny, stepnumber=1, caption=Tworzenie zasobu JDBC., firstnumber=1]

asadmin create-jdbc-connection-pool
--datasourceclassname=com.mysql.jdbc.jdbc2.optional.MysqlDataSource
--restype=javax.sql.DataSource
--property="user=mainStorage:password=registrationServer1:url=
jdbc\:mysql\://192.168.1.20\:3306/secstorage" mysqlRegPool

asadmin create-jdbc-resource
--connectionpoolid mysqlRegPool jdbc/secstorage
\end{lstlisting}

\subsection{Realizacja testów}

W celu zapewnienia jakoœci systemu utworzonych zosta³o szereg testów:
\begin{itemize}
	\item jednostkowych - testy automatyczne,
	\item integracyjnych - testy automatyczne,
	\item akceptacyjnych - testy manualne,
	\item	wydajnoœciowych - testy automatyczne,
	\item bezpieczeñstwa - testy automatyczne i manualne,
\end{itemize}

Wszystkie testy automatyczne zosta³y napisane przy pomocy biblioteki \texttt{Junit 4}. Testy matualne zosta³y wykonane rêczne, a ich wyniki zosta³y udokumentowane w postaci screenów z programu. Przedstawione zostan¹ jedynie wybrane metody testuj¹ce.

\subsubsection{Testy jednostkowe}

W celu przetestowania pojedynczych modu³ów systemu utworzony zosta³ szereg testów jednostkowych. Ka¿dy projekt posiada w³asne testy jednostkowe testuj¹ce jego w³asne modu³y. Do realizacji testów jednostkowych zosta³a u¿yta biblioteka \texttt{Junit 4}.
Wszystkie testy na wszystkich elementach systemu przechodz¹ pomyœlnie.

Krytycznym elementem dla dzia³ania systemu jest podzia³ wygenerowanego \texttt{klucza prywatnego} na \texttt{klucz prywatny u¿ytkownika} oraz \texttt{klucz prywatny mediatora}. Na listingu \ref{lst:mediatorKeyTest1} przedstawiona zosta³a metoda testuj¹ca powy¿sz¹ procedurê. W metodzie generowana jest \texttt{para kluczy}, nastêpnie wywo³ywana jest metoda, która jako parametry dostaje \texttt{klucz serwisoy}, d³ugoœæ bitow¹ \texttt{klucza publicznego}, wartoœci \texttt{delta} oraz \texttt{w³asny klucz mediatora}. Wartoœæ \texttt{delta} oraz \texttt{w³asny klucz mediatora} zosta³y zakodowane w metodzie testuj¹cej. Metoda ta zwraca \texttt{klucz prywatny mediatora}. Sprawdzane jest czy d³ugoœæ bitowa wygenerowanego \texttt{klucza prywatnego mediatora} jest d³u¿sza od d³ugoœci \texttt{klucza publicznego}. W kolejnych krokach wyci¹gane s¹ liczby pierwsze z klucza prywatnego oraz liczona wartoœæ fi. Nastêpnie od \texttt{klucza prywatnego} wygenerowanego na pocz¹tku odejmowany jest modulo \texttt{fi} \texttt{klucz prywatny mediatora} a wynik zapisywany jest jako \texttt{klucz prywatny u¿ytkownika}. Na koñcu \texttt{klucz prywatny mediatora} i \texttt{klucz prywatny u¿ytkownika} s¹ dodawane modulo \texttt{fi}. nastêpnie wykonywane jest porównanie otrzymanej sumy do wygenerowanego na pocz¹tku wartoœci \texttt{klucza prywatnego}.\\
Test wykonuje siê pomyœlnie.\\

\begin{lstlisting}[label={lst:mediatorKeyTest1}, language=Java, frame=lines, numberstyle=\tiny, stepnumber=1, caption=PartKeyGeneratorTest.java., firstnumber=1]
package net.ddns.falcoboss.mediatorserver.service.signature;

\\Import bibliotek
import java.math.BigInteger;
import java.security.InvalidKeyException;
import java.security.KeyFactory;
import java.security.KeyPair;
import java.security.NoSuchAlgorithmException;
import java.security.PrivateKey;
import java.security.PublicKey;
import java.security.SignatureException;
import java.security.interfaces.RSAPrivateKey;
import java.security.interfaces.RSAPublicKey;
import java.security.spec.InvalidKeySpecException;
import java.security.spec.RSAPrivateCrtKeySpec;
import org.junit.Assert;
import org.junit.Before;
import org.junit.Test;
import net.ddns.falcoboss.common.cryptography.KeyHelper;
import net.ddns.falcoboss.common.cryptography.PublicKeyCryptography;

public class PartKeyGeneratorTest {
	public final static int delta = 120;
	KeyPair newKeyPair = null;
	PrivateKey mediatorOwnKey = null;
	
	\\Metoda dostarczaj¹ca klucze.
	@Before
	public void generateKey() throws Exception {

		\\Generowanie klucza do podzia³u.
		newKeyPair = PublicKeyCryptography.createKeyPair();

		\\Wartoœæ modu³ klucza w³asnego mediatora.
		String mediatorOwnModulus = "APGBsXYWAjLQewbQWxmoyQaY+EllH1MdXoGVUW0rmfP+g8XMw2AqAXgW5NHZK6dwIZ0CVzkBDf0M8JMWMDqUsGho0H+N1q+NIiwADmg061AEoS2rL9Jm5ulm7VPmShnoRuNog7s+PR3F8xSJMGbHctBQ1gRdqGst3q9NsehLdmJ731YiNCMhrC/X4TRgbudCL0CDVJ+J6mntf11HNzXO+c5EvAmyaf4zJDWIU0veosOCK6EMcFYv5HQWkmwEcIT5DdKdM8af10tMx36uC3+UlXYQDWHd96OupWRBLStyZIWcHJqWPrrf2GsJf5MoYt1ZHmZZQ4ee2d9vJA+zAzt6qjc=";
		
		\\Wartoœæ eksponenty klucza w³asnego mediatora.		
		String mediatorOwnPrivateExponent = "VBXV1cl/5nVUAGFW9q4fn95uxA8jQur81p1Ihnwh1CQPeTT76WV2sXs3HCFC479U1LfV6pEFb8+ri2q0TBEtAo1L2r1lvCWlejBi08FpFKkn/SCXO+h8CVO+2fFaZ37J/6+J/g2DdfRP2ByT75UN0p3yhf6d/wMvf1XL1ZdAlrThNuW/ju9JtLGlRnHLNStbofCwNV4c7NzmPT7KCSlgrDRfXQX7XLx+D+hFpZPWypErV+UlgRM0x2cfp+K2gE6Y+tYCBXLsZZ3I3q+bTDwmiOte+2sn0uop7HuC7CxvK+wUxqcOgkOMTWy2oA4U7OrtQXCL6hAHya/DlEGmCyH0UQ==";
		
		\\W³asny klucz prywatny mediatora.
		mediatorOwnKey = KeyHelper.getPrivateKeyFromBase64ExponentAndModulus(mediatorOwnPrivateExponent,
				mediatorOwnModulus);
	}
	
	\\Metoda testuj¹ca.
	@Test
	public void testKeySplit()
			throws NoSuchAlgorithmException, 
			InvalidKeySpecException, InvalidKeyException, SignatureException {

		PublicKey commonPublicKey = newKeyPair.getPublic();
		RSAPrivateKey commonPrivateKey = (RSAPrivateKey) newKeyPair.getPrivate();
		BigInteger modulus = ((RSAPublicKey) commonPublicKey).getModulus();
		BigInteger commonPrivateExponent = commonPrivateKey.getPrivateExponent();
		
		//Wywo³ywanie metody generuj¹cej klucz prywatny mediatora.
		BigInteger mediatorPrivateExponent = 
		PartKeyGenerator.generateFinalizationKeyExponent("testServiceKey",
		modulus.bitLength(), delta, mediatorOwnKey);

		//Sprawdzanie d³ugoœci wygenerowanego klucza.
		Assert.assertTrue(modulus.bitLength() < mediatorPrivateExponent.bitLength());
		
		//Wyci¹ganie liczb pierwszych z klucza prywatnego.
		KeyFactory keyFactory = KeyFactory.getInstance("RSA");
		RSAPrivateCrtKeySpec pkSpec = keyFactory.getKeySpec(commonPrivateKey, 
		RSAPrivateCrtKeySpec.class);
		BigInteger pMinusOne = pkSpec.getPrimeP().subtract(BigInteger.ONE);
		BigInteger qMinusOne = pkSpec.getPrimeQ().subtract(BigInteger.ONE);
		
		//Obliczanie wartoœci fi.
		BigInteger fi = (pMinusOne.multiply(qMinusOne));
		
		//Sk³adanie klucza.
		BigInteger userPrivateExponent = 
		(commonPrivateExponent.subtract(mediatorPrivateExponent)).mod(fi);
		
		//Porównanie wartoœci z³o¿onego klucza do klucza wygenerowanego na pocz¹tku.
		Assert.assertEquals(commonPrivateKey.getPrivateExponent(),
				(userPrivateExponent.add(mediatorPrivateExponent)).mod(fi));
	}
}

\end{lstlisting}

Kolejna metoda testuje podpisywanie danych przy pomocy czêœciowych kluczy. Pocz¹tek metody nie ró¿ni siê niczym od metody testuj¹cej generowanie klucza czêœciowego przedstawionej na listingu \ref{lst:mediatorKeyTest1}. W dalszej czêœci metody przedstawionej na listingu \ref{lst:signatureAssemblyTest1} od linii 80 tworzony jest \texttt{skrót SHA512} z pola tekstowego. \texttt{Skrót} ten jest nastêpnie podpisywany przy pomocy \texttt{klucza prywatnego} wygenerowanego na pocz¹tku. Nastêpnie \texttt{skrót} jest podpisywany osobno przy pomocy \texttt{klucza prywatnego u¿ytkownika} i \texttt{klucz prywatny mediatora}. W kolejnym etapie dwa ostanie \texttt{podpisy} sk³adane s¹ w jeden przy pomocy operacji mno¿enia modulo. Na samym koñcu nastêpuje test z³o¿onego \texttt{podpisu}, który polega na porównaniu go do podpisu z³o¿onego przy pomocy \texttt{klucza prywatnego} przed podzia³em. 
Test koñczy siê sukcesem.\\


\begin{lstlisting}[label={lst:signatureAssemblyTest1}, language=Java, frame=lines, numberstyle=\tiny, stepnumber=1, caption=SignatureAssemblyTest.java., firstnumber=80]
			//Utworzenie skrótu z tekstu.
			byte[] message = 
			SHA512.hashText("RSA Signature Test String").getBytes();
			BigInteger bigIntegerFileHash = 
			new BigInteger(1,message);
			
			//Podpis przy pomocy klucza przed podzia³em.
			BigInteger commonSignatureB = 
			bigIntegerFileHash.modPow(commonPrivateExponent, modulus);
			
			//Podpis przy pomocy klucza prywatnego u¿ytkownika.
			BigInteger userSignatureB = 
			bigIntegerFileHash.modPow(userPrivateExponent, modulus);

			//Podpis przy pomocy klucza prywatnego mediatora.
			BigInteger mediatorSignatureB = 
			bigIntegerFileHash.modPow(mediatorPrivateExponent, modulus);

			//Porównanie z³o¿onego podpisu
			//do podpisu z³o¿onego przy pomocy niepodzielonego klucza prywatnego.
			Assert.assertEquals(commonSignatureB,
			(userSignatureB.multiply(mediatorSignatureB)).mod(modulus));	
    }
}
\end{lstlisting}

\subsubsection{Testy integracyjne}

W celu wykrycia b³êdów w interfejsach oraz zapewnienia bezb³êdnej komunikacji pomiêdzy modu³ami, utworzonych zosta³o szereg testów integracyjnych. Aby testy automatyczne zakoñczy³y siê pomyœlnie, system musi zostaæ uruchomiony oraz porawnie skonfigurowany. Wszystkie testy integracyjne znajduj¹ siê w projekcie \texttt{integration-test}.

Na listingu \ref{lst:abstractConnectionTest1} przedstawiona zosta³a klasa abstrakcyjna, która s³u¿y jako baza do testów interfejsu \texttt{serwera dostêpowego}. Klasa odpowiedzialna jest za stworzenie i zainicjowanie obiektu \texttt{klienta serwisu REST} oraz skonfigurowanie biblioteki odpowiedzialnej za serjalizacjê obiektów do formatu JSON. Klasa ustawia klientowi adres \texttt{serwera dostêpowego} oraz przechowuje obliczone skróty hase³ testowych.

\begin{lstlisting}[label={lst:abstractConnectionTest1}, language=Java, frame=lines, numberstyle=\tiny, stepnumber=1, caption=PartKeyGeneratorTest.java., firstnumber=1] 
package net.ddns.falcoboss.integration.test.messanger;

import javax.ws.rs.client.Client;
import javax.ws.rs.client.ClientBuilder;
import javax.ws.rs.client.WebTarget;

import org.eclipse.persistence.jaxb.rs.MOXyJsonProvider;
import org.glassfish.jersey.client.ClientConfig;
import org.json.JSONObject;
import org.junit.Before;

import net.ddns.falcoboss.common.cryptography.SHA512;

public abstract class AbstractConnectionTest {
    Client client;
    WebTarget webTarget;
    JSONObject authToken;
    
	String password1Hash;
	String password2Hash;

    @Before
    public void initClient() throws Exception {
    	password1Hash = SHA512.hashText("password1");
    	password2Hash = SHA512.hashText("password2");
    	
		ClientConfig cc = new ClientConfig();
		cc.register(MOXyJsonProvider.class);
		
        this.client = ClientBuilder.newClient(cc);
        this.webTarget = 
this.client.target(
"http://localhost:8080/registration-server/rest/service/");
    }
}
\end{lstlisting}

Z klasy z listingu \ref{lst:abstractConnectionTest1} dziedziczy klasa testowa przedstawiona na listingu \ref{lst:loginLogoutTest1}. Klasa ta testuje proces logowania oraz wylogowywania z systemu symuluj¹c \texttt{klienta}. Przy logowaniu porównywany jest kod odpowiedzi serwera do wartoœci 200 (oznacza to poprawne zalogowanie). Nastêpnie sprawdzany jest token. Przy wylogowywaniu sprawdzany jest jedynie kod odpowiedzi, wartoœæ 204 odpowiada poprawnemu wylogowaniu siê z serwra.
Test koñczy siê sukcesem.

\begin{lstlisting}[label={lst:loginLogoutTest1}, language=Java, frame=lines, numberstyle=\tiny, stepnumber=1, caption=ServiceRegisterLoginLogoutTest.java., firstnumber=1] 
package net.ddns.falcoboss.integration.test.messanger;


import javax.ws.rs.client.Entity;
import javax.ws.rs.core.MediaType;
import javax.ws.rs.core.Response;

import org.json.JSONObject;
import org.junit.After;
import org.junit.Assert;
import org.junit.Test;

import net.ddns.falcoboss.common.cryptography.SHA512;
import net.ddns.falcoboss.common.transport.objects.HTTPHeaderNames;
import net.ddns.falcoboss.common.transport.objects.UsernameAndPasswordTO;

public class ServiceRegisterLoginLogoutTest extends AbstractConnectionTest{
	private String serviceKey = "f80ebc87-ad5c-4b29-9366-5359768df5a1";
	
    @Test
    public void testConnection() throws Exception{
    	String passwordHash = SHA512.hashText("password1");
    	UsernameAndPasswordTO usernameAndPasswordBean = new UsernameAndPasswordTO("username1",passwordHash);	
    	Response response = webTarget.path("login/").request().header(HTTPHeaderNames.SERVICE_KEY, serviceKey).
    	accept(MediaType.APPLICATION_JSON_TYPE).post(Entity.entity(usernameAndPasswordBean, MediaType.APPLICATION_JSON_TYPE));
        Assert.assertEquals(200, response.getStatus());
        authToken = new JSONObject(response.readEntity(String.class));
        Assert.assertNotNull(authToken.get("auth_token"));
    }
    
    @After
    public void logout(){
    	Response response = webTarget.path("logout/").request().header(HTTPHeaderNames.SERVICE_KEY, serviceKey).header(HTTPHeaderNames.AUTH_TOKEN, authToken.get("auth_token")).post(null);
    	Assert.assertEquals(204, response.getStatus());
    }
}
\end{lstlisting}


\subsubsection{Testy akceptacyjne}

Wszystkie testy akceptacyjne zosta³y przeprowadzone manualnie oraz udokumentowane w postaci zrzutu ekranu aplikacji. Przetestowane zosta³y wybrane przypadki u¿ycia.

Po uruchomieniu programu wyœwietlone zostaje okno logowania z przyciskiem \texttt{Zaloguj}. Pomyœlne zalogowanie do systemu nastêpuje w przypadku podania prawid³owego \texttt{loginu} i \texttt{has³a} oraz poprawnej konfiguracji pliku \texttt{property.config}.

W nastêpuj¹cych przypadkach nie ma mo¿liwoœci zalogowania siê, w oknie logowania zostaje wyœwietlony komunikat z b³êdem:

\begin{itemize}
	\item brak \texttt{loginu} lub \texttt{has³a},
	\item niepoprawny \texttt{login} i \texttt{has³o},
	\item niepoprawny adres serwisu w pliku \texttt{property.config},
	\item niepoprawny \texttt{klucz serwisowy} lub jego brak.
\end{itemize}

Na rysunku \ref{wrongPassword1} przedstawione zosta³o okno aplikacj \texttt{klient}, po próbie zalogowania ze z³ym \texttt{loginem} lub \texttt{has³em}, albo ze \texttt{kluczem serwisowym}.

\begin{figure}[h!]
\begin{center}
\includegraphics[width=0.9\textwidth]{wrongPassword.png}
\end{center}
\caption{Komunikat w przypadku b³êdnego loginu, has³a lub klucza serwisowego.} \label{wrongPassword1}
\end{figure}

Po poprawnej autoryzacji aplikacja \texttt{klient} wyœwietala okno z \texttt{list¹ kontaktów}. Po klikniêciu na \texttt{kontakt} mo¿emy rozpocz¹æ komunikacje tekstow¹. Na rysunku \ref{messangerTest1} przedstawione zosta³o g³ówne okno programu, na nim okno wiadomoœci z aktywn¹ rozmow¹, oraz okno z informacj¹ o \texttt{tokenie} 

\newpage

\begin{figure}[h!]
\begin{center}
\includegraphics[width=0.7\textwidth]{messangerTest.png}
\end{center}
\caption{G³ówne okno programu, okno wiadomoœci i okno tokena.} \label{messangerTest1}
\end{figure}

Kolejny przeprowadzony test sprawdza mo¿liwoœæ sk³adania oraz weryfikacjê podpisu cyfrowego. W zak³adce \texttt{podpis cyfrowy} po wczytaniu pliku w okienu przedstawiony zostanie skrót pliku w postaci szestnastkowej. Nastêpnie po klikniêciu przycisku \texttt{podpisz plik} system w sposób rozproszony wygeneruje podpis, który po chwili pojawia siê w polu \texttt{podpis plku} zakodowany w postaci Base64. W katalogu g³ównym programu podpis zostaje automatycznie zapisany do plku, nazwa pliku generowana jest wed³ug nastêpuj¹cego schematu:

\begin{itemize}
	\item \texttt{<nazwa\_wczytanego\_plku>.<piecz¹tka\_czasu>.sig}
\end{itemize}

Aby zweryfikowaæ podpisany \texttt{plik} nale¿y za³adowaæ go do programu wraz z jego \texttt{podpisem} oraz \texttt{kluczem publicznym} u¿ytkownika, który go podpisa³, a nastêpnie klikn¹æ w przycisk \texttt{weryfikuj podpis}. W przypadku prawid³owego \texttt{klucza publicznego}, \texttt{podpisu} oraz \texttt{pliku} wyœwietlony zostaje komunikat o pomyœlnej weryfikacji. W przypadku gdy \texttt{plik} zosta³ zmieniony, wczytany zosta³ niepoprawny \texttt{podpis} lub \texttt{klucz publiczny}, \texttt{klient} wyœwietli informacjê o niepoprawnej weryfikacji. Na rysunku \ref{signatureTest1} przedstawione zosta³y obydwa przypadki.

\begin{figure}[h!]
\begin{center}
\includegraphics[width=0.7\textwidth]{signatureTest.png}
\end{center}
\caption{Pomyœlna oraz niepomyœlna weryfikacja podpisu.} \label{signatureTest1}
\end{figure}

\newpage


\subsection{Ocena wydajnoœci operacji generowania kluczy}

System domyœlnie generuje klucze 1024-bitowe. W œrodowiku produkcyjnym zalecane jest przejœcie do d³ugoœci 2048-bitowej, taka d³ugoœæ klucza uwa¿ana jest powszechnie za bazpieczn¹ i obecnie najczêœciej stosowana. Wzrost mocy obliczeniowej komputerów powoduje, ¿e w przysz³oœci standardem mog¹ staæ siê klucze 4096-bitowe. Na listingu \ref{lst:keygentimeTest1} przedstawiony zosta³ test obliczaj¹cy czasy generowania kluczy w zale¿noœci od d³ugoœci bitowej klucza. Test oblicza œredni¹ czasów z 6 prób. Wyniki testu zosta³y przedstawione na obrazku \ref{keygenTimes1}. Generowanie kluczy jest najbardziej zasobo¿erna operacja w ca³ym systemie. W przypadku za¿¹dania klucza w tym samym czasie przez wiêksz¹ iloœæ u¿ytkowników mo¿e dojœc do znacznego spadku wydajnoœci \texttt{serwera dostêpowego}. Modu³ do generowania kluczy stanowi osobn¹ bibliotekê i mo¿e byæ w przysz³oœci ³atwo wydzielony jako niezale¿y wêze³ systemu.

\begin{lstlisting}[label={lst:keygentimeTest1}, language=Java, frame=lines, numberstyle=\tiny, stepnumber=1, caption=ServiceRegisterLoginLogoutTest.java., firstnumber=1] 
@Test
public void testCreateKeyPairTimes() throws NoSuchAlgorithmException {
	 long timeStart;
	 long timeEnd;
	 
	 long tt = 0;
	 for(int j=512; j<4097; j=j+512)
	 {
		 for(int i = 0;  i<6; i++){
			 try {
				 timeStart = System.currentTimeMillis();
				 KeyPairGenerator keygen = KeyPairGenerator.getInstance("RSA");
				 keygen.initialize(j);
				 keygen.generateKeyPair();
				 timeEnd = System.currentTimeMillis();
				 tt += (timeEnd - timeStart);
			 }
			 catch (Exception e) {
				 e.printStackTrace();
			 }		
		 }
		 System.out.println("(" + j + "," + (tt/6) + ")");	
	 }
}
\end{lstlisting}

\begin{figure}
\begin{tikzpicture}[scale=1.5, font=\scriptsize]
\begin{axis}[
title={Czas generowania kluczy},
title style={text width=12em},
xlabel={D³ugoœæ bitowa kluczy [bit]},
ylabel={Czas generowania [s]},
xtick={512,1024,1536,2048,2560,3072,3584,4096},
xmin=512,xmax=4096,
ymin=0,ymax=10,
legend pos=north west,
ymajorgrids=true,grid style=dashed
]

\addplot[color=red,mark=*]
coordinates {
(512,0.248)
(1024,0.304)
(1536,0.430)
(2048,1.410)
(2560,1.933)
(3072,2.965)
(3584,6.403)
(4096,9.767)
};

\addplot[color=blue,mark=square]
coordinates {
(512,0.173)
(1024,0.191)
(1536,0.315)
(2048,0.912)
(2560,1.788)
(3072,2.453)
(3584,4.291)
(4096,7.457)
};
\legend{Core 2 Duo T6500 2.1GHZ - 4GB,i7-4700MQ 2.4GHz - 8GB RAM}
\end{axis}
\end{tikzpicture}
\caption{Czasy faktoryzacji liczb.} \label{keygenTimes1}
\end{figure}

\subsection{Ocena wydajnoœci transmisji danych}

//TODO test w¹tki wysy³aj¹ce losowe wiadomoœci.

\subsection{Ocena zachowania w przypadku awarii}

//TODO screeny z testów

\subsection{Ocena bezpieczeñstwa}

Bezpieczeñstwo podpisu cyfrowego opiera siê o trudnoœæ faktoryzacji, czyli rozk³adu na czynniki pierwsze du¿ych liczb. Na listingu \ref{lst:factorPrimeTest1} przedstawiony zosta³ test realizuj¹cy to zadanie. Test w pêtli generuje dwie liczby pierwsze, zaczynaj¹c od liczb 3 bitowych, nastêpnie je mno¿y, a otrzymany wynik mno¿enia próbuje roz³o¿yæ na czynniki pierwsze. Program liczy œredni¹ czasów dla 6 prób. Wyniki zosta³y przedstawione na rysunku \ref{factorTimes1}. Jak widaæ na rysunku czas roœnie bardzo szybko do w stosunku do d³ugoœci bitowej liczby. Rozk³ad liczby 62-bitowej na komputerze 2 rdzeniowym trwa ju¿ ok 6 minut. Pojedyñcza próba faktoryzacji liczby 64bitowej trwa³a ponad godzinê. Roz³o¿enie liczby 1024-bitowej jest niemo¿liwe w realnym czasie. Zagro¿eniem dla bezpieczeñstwa algorytmu RSA mog¹ byæ komputery kwantowe.

\begin{lstlisting}[label={lst:factorPrimeTest1}, language=Java, frame=lines, numberstyle=\tiny, stepnumber=1, caption=FactorBigIntegerTest.java., firstnumber=1] 
package net.ddns.falcoboss.integration.test.factorization;

import java.math.BigInteger;
import java.util.LinkedList;
import java.util.Random;

import org.junit.Test;

public class FactorBigIntegerTest {

	public static LinkedList<BigInteger> tdFactors(BigInteger n) {
		BigInteger tmp = n;
		BigInteger two = BigInteger.valueOf(2);
		LinkedList<BigInteger> factors = new LinkedList<BigInteger>();
		if (tmp.compareTo(two) < 0) {
			throw new IllegalArgumentException("Liczba musi by wieksza niz 1!");
		}
		while (tmp.mod(two).equals(BigInteger.ZERO)) {
			factors.add(two);
			tmp = tmp.divide(two);
		}
		if (tmp.compareTo(BigInteger.ONE) > 0) {
			BigInteger f = BigInteger.valueOf(3);
			while (f.multiply(f).compareTo(tmp) <= 0) {
				if (tmp.mod(f).equals(BigInteger.ZERO)) {
					factors.add(f);
					tmp = tmp.divide(f);
				} else {
					f = f.add(two);
				}
			}
			factors.add(tmp);
		}
		return factors;
	}

	@Test
	public void testFactorization() {
		BigInteger nx = BigInteger.valueOf(100);
		BigInteger n;		
		long startTime;
		long endTime;
		long totalTime;
		System.out.println("start...");
		for (BigInteger i = BigInteger.valueOf(2); nx.compareTo(i) >
			0; i = i.add(BigInteger.valueOf(1))) {
			long tt = 0;
			for(int j=0; j<6; j++)
			{
				BigInteger p = BigInteger.probablePrime(i.intValue(), new Random());
				BigInteger q = BigInteger.probablePrime(i.intValue(), new Random());
				n = p.multiply(q);
				startTime = System.currentTimeMillis();
				LinkedList<BigInteger> lst = tdFactors(n);
				endTime = System.currentTimeMillis();
				tt += totalTime = endTime - startTime;
			}
			System.out.println("(" + n.bitLength() + "," + tt/6 + ")");
		}
	}
}
\end{lstlisting}


\begin{figure}
\begin{tikzpicture}[scale=1.5, font=\scriptsize]
\begin{axis}[
title={Czas faktoryzacji},
title style={text width=12em},
xlabel={D³ugoœæ bitowa faktoryzowanej liczby [bit]},
ylabel={Czas faktoryzacji [s]},
xmin=0,xmax=62,
ymin=0,ymax=200,
legend pos=north west,
ymajorgrids=true,grid style=dashed
]

\addplot[color=red,mark=*]
coordinates {
(3,0)
(6,0)
(8,0)
(10,0)
(12,0)
(13,0)
(16,0)
(17,0)
(19,0)
(21,0)
(23,0.001)
(26,0.003)
(28,0.004)
(30,0.007)
(32,0.012)
(33,0.023)
(35,0.029)
(38,0.062)
(39,0.085)
(42,0.189)
(44,0.317)
(46,0.685)
(47,1.269)
(50,2.576)
(52,4.800)
(53,10.142)
(54,13.585)
(55,18.173)
(58,43.747)
(60,90.796)
(61,149.298)
(62,399.298)
};

\addplot[color=blue,mark=square]
coordinates {
(3,0)
(5,0)
(8,0)
(10,0)
(12,0)
(14,0)
(16,0)
(18,0)
(20,0)
(21,0)
(24,0)
(25,0.002)
(28,0.002)
(30,0.004)
(31,0.012)
(34,0.032)
(36,0.044)
(37,0.073)
(39,0.196)
(42,0.207)
(43,0.371)
(46,0.759)
(48,0.802)
(50,1.834)
(52,4.504)
(54,9.562)
(55,13.235)
(57,19.767)
(60,56.716)
(61,98.123)
(62,234.122)
};
\legend{Core 2 Duo T6500 2.1GHZ - 4GB,i7-4700MQ 2.4GHz - 8GB RAM}
\end{axis}
\end{tikzpicture}
\caption{Czasy generowania kluczy.} \label{factorTimes1}
\end{figure}

Komunikacja miêdzy wêz³ami mo¿e byæ szyfrowana przy pomocy protoko³u HTTPS, który opiera siê na TLS, a ten korzysta równie¿ z kryptografi asymetrycznej. Wszystkie próby zalogowania siê do systemu z nieprawid³owym \texttt{loginem} lub \texttt{has³em} koñcz¹ siê niepowodzeniem, dodadkowym elementem podnosz¹cym bezpieczeñstwo jest \texttt{klucz serwisowy}. Generowanie \texttt{pary kluczy} to jedyny oprócz logowania przypadek u¿ycia wymagaj¹cy dodadkowej walidacji. Równie¿ tam w przypadku nieprawid³owego \texttt{loginu} lub \texttt{has³a} wyœwietlany jest komunikat z b³êdem, który przedsationy zosta³ na rysunku ref{wrongPasswordKey1}.
Komunikat wyœwietlany jest na tle zak³adki do \texttt{generowania pary kluczy}.

\newpage

\begin{figure}[h!]
\begin{center}
\includegraphics[width=0.8\textwidth]{wrongPasswordKey.png}
\end{center}
\caption{Generowanie klucza - z³e has³o.} \label{wrongPasswordKey1}
\end{figure}

\section{Podsumowanie}

Utworzony system pozwala na swobodn¹ komunikacjê pomiêdzy u¿ytkownikami, zapewnia te¿ podstawow¹ funkcjonalnoœæ podpisu cyfrowego. Bezpieczeñstwo tego systemu podniesione jest dziêki dodadkowej stronie podpisuj¹cej. Nawet je¿eli osoba trzecia zdobêdzie klucz prywatny u¿ytkownika, to nie bêdzie w stanie podpisaæ nim dokumentów.
Utworzony system mo¿e pos³u¿yæ jako baza do rozwoju bardziej zaawansowanych rozwi¹zañ. ,dziêki modu³owej budowie mo¿e byæ ³atwo modyfikowany i rozszerzany.

//TODO dokonczyc


\newpage

\begin{thebibliography}{99}

\bibitem{JavaEE6Leksykon1}Arun Gupta. \emph{Java EE 6 Leksykon kieszonkowy}, Wydawnictwo HELION, Gliwice, 2013. ISBN 978-83-246-6640-9.

\bibitem{JavaEE6Przewodnik1}Eric Jendrock, Ian Evans, Devika Gollapudi, Kim Haase, Chinmayee Srivathsa. \emph{Java EE 6 Przewodnik, Wydanie IV}, Wydawnictwo HELION, Gliwice, 2012. ISBN 978-83-246-3847-5.

\bibitem{JavaEEZaawansowany6Przewodnik1}Eric Jendrock, Ricardo Cervera-Navarro, Ian Evans, Devika Gollapudi, Kim Haase, William Markito, Chinmayee Srivathsa. \emph{Java EE 6 Zaawansowany Przewodnik, Wydanie IV}, Wydawnictwo HELION, Gliwice, 2012. ISBN 978-83-246-7393-3.

\bibitem{Rest1} Bhakti Mehta. \emph{REST Najlepsze praktyki i wzorce w jêzyku Java}, Wydawnictwo HELION, Gliwice, 2015. ISBN 978-83-283-0644-8.

\bibitem{SieciKomputerowe1}Andrew S. Tanenbaum. \emph{Sieci Komputerowe}, Wydawnictwo HELION, Gliwice, 2004. ISBN 83-7361-557-1. Bezpieczeñstwo w sieciach komputerowych, s.641-740.

\bibitem{InzynieriOprogramowania1}Bernd Bruegge, Allen H. Dutoit. \emph{In¿ynieria oprogramowania w ujêciu obiektowym. UML, wzorce projektowe i Java}, Wydawnictwo HELION, Gliwice, 2012. ISBN 978-83-246-2872-8.

\bibitem{Kryptografia1}William Stallings. \emph{Kryptografia i bezpieczeñstwo sieci komputerowych. Matematyka szyfrów i techniki kryptologii}, Wydawnictwo HELION, Gliwice, 2010. ISBN 978-83-246-2986-2.

\bibitem{mRSA1}Miros³aw Kutylowski, Przemys³aw Kubiak. \emph{Mediated RSA cryptography specification for additive private key splitting (mRSAA)}, Internet Szkic, 2013 [dostêp 15 grudnia 2015] Dostêpne w internecie:
\url{https://tools.ietf.org/html/draft-kutylowski-mrsa-algorithm-03}

\bibitem{Oracle1}\emph{Oracle® Security Developer Tools Reference}, ¯ród³o, 2006 [dostêp 15 grudnia 2015] Dostêpne w internecie:
\url{https://docs.oracle.com/cd/B28196_01/idmanage.1014/b28165/crypto.htm}

\bibitem{KryptografiaAsymetrczna1}\emph{Kryptografia asymetryczna i jej zastosowanie w algorytmach komunikacji}, ¯ród³o, 2006 [dostêp 29 grudnia 2015] Dostêpne w internecie:
\url{http://kis.pwszchelm.pl/publikacje/V/Bartyzel.pdf}

\bibitem{SystemyRozproszone1}\emph{Systemy rozproszone}, Wyk³ad, 2006 [dostêp 28 grudnia 2015] Dostêpne w internecie:
\url{http://wazniak.mimuw.edu.pl/index.php?title=Systemy_rozproszone}

\bibitem{SystemyEE1}Zofia Kruczkiewicz. \emph{Modelowanie i analiza systemów informatycznych 1}, Wyk³ady, 2014 [dostêp 28 grudnia 2015] Dostêpne w internecie:
\url{http://zofia.kruczkiewicz.staff.iiar.pwr.wroc.pl/wyklady/analizasi/}

\bibitem{JavaEETutorial1}\emph{Java Platform, Enterprise Edition: The Java EE Tutorial}, ¯ród³o, 2014 [dostêp 15 grudnia 2015] Dostêpne w internecie:
\url{https://docs.oracle.com/javaee/7/JEETT.pdf}

\bibitem{JaxRSFilters1}\emph{Filters and Handlers Revisited}, ¯ród³o, 2011 [dostêp 24 stycznia 2015] Dostêpne w internecie:
\url{https://java.net/projects/jax-rs-spec/pages/PreMatchingFilters}

\bibitem{Jersey1}\emph{Jersey}, ¯ród³o, 2015, [dostêp 24 stycznia 2016] Dostêpne w internecie:
\url{https://jersey.java.net/documentation/latest/index.html}

\end{thebibliography}

\end{document}
