\documentclass[12pt,titlepage]{article}
\usepackage[bottom=7em]{geometry}

%\usepackage{amsmath}
%\usepackage{amsfonts}
%\usepackage{amssymb}
%\usepackage{algorithm}
%\usepackage{algorithmic} 
%
%\usepackage{theorem}
%\usepackage{graphicx}
%
%\usepackage[cp1250]{inputenc}
%\usepackage[T1]{fontenc}
%\usepackage[polish]{babel}
%\usepackage[MeX]{polski}
%
%\usepackage{makeidx}
%\usepackage{listings}
%\usepackage{url}
%\usepackage{Here}

\usepackage{graphicx}
\usepackage{graphics}
\usepackage{epsfig}
\usepackage{mathtools}
\usepackage{amssymb}
\usepackage{amsthm}
\usepackage{booktabs}
\usepackage{stmaryrd}
\usepackage{url}
\usepackage{longtable}
\usepackage[figuresright]{rotating}

%\usepackage[MeX]{polski}
\usepackage[cp1250]{inputenc}


\usepackage[T1]{fontenc}
%\usepackage[latin2]{inputenc}
\usepackage[polish]{babel}

\usepackage{geometry}
\usepackage{pslatex}
\usepackage{ulem}

\usepackage{lipsum}

\usepackage{listings}
\usepackage{url}
\usepackage{Here}

\usepackage{color}
\definecolor{szary}{gray}{0.6}% jasnoszary

\setlength{\textwidth}{400pt}
\lstset{numbers=left,
			numberstyle=\tiny, 
			basicstyle=\scriptsize\ttfamily, 
			breaklines=true, 
			captionpos=b, 
			tabsize=2}

\usepackage[ruled,vlined,linesnumbered]{algorithm2e}

\selectlanguage{polish}

\newcommand{\RR}{\mathbb{R}}
\newcommand{\NN}{\mathbb{N}}
\newcommand{\QQ}{\mathbb{Q}}
\newcommand{\ZZ}{\mathbb{Z}}
\newcommand{\TAB}{\hspace{0.50cm}}
\newcommand{\IFF}{\leftrightarrow}
\newcommand{\IMP}{\rightarrow}

\newtheorem{theorem}{Twierdzenie}[section]
\newtheorem{lemma}{Lemat}[section]
\newtheorem{example}{Przyk³ad}[section]
\newtheorem{corollary}{Wniosek}[section]
\newtheorem{definition}{Definicja}[section]

\sloppy
\overfullrule=2cm

\makeindex

\begin{document}

\pagestyle{empty}

\begin{titlepage}
\vspace*{\fill}
\begin{center}
\begin{picture}(300,510)
  \put( -100,540){\makebox(0,0)[l]{\large \bf \textsc{Wydzia³ Elektroniki}}}
  \put( -100,520){\makebox(0,0)[l]{\large \bf \textsc{Politechniki Wroc³awskiej}}}

  \put( -100,340){\makebox(0,0)[l]{\LARGE \bf \textsc{Zastosowanie mechanizmów kryptograficznych}}}
\put( 20,310){\makebox(0,0)[l]{\LARGE \bf \textsc{przy projektowaniu}}}
\put( -100,280){\makebox(0,0)[l]{\LARGE \bf \textsc{wieloplatformowych aplikacji rozproszonych}}}


  \put(90,250){\makebox(0,0)[l]{\large     \textsc{in¿. Micha³ Lange}}}

  \put(200, 80){\makebox(0,0)[l]{\large  {Praca magisterska napisana}}}
  \put(200, 60){\makebox(0,0)[l]{\large  {pod kierunkiem}}}
  \put(200, 40){\makebox(0,0)[l]{\large  {dr in¿. Roberta Wójcika}}}

  \put(100,-80){\makebox(0,0)[bl]{\large \bf \textsc{Wroc³aw 2016}}}
\end{picture}
\end{center}
\vspace*{\fill}
\end{titlepage}

\tableofcontents

\newpage

\listoffigures
\addcontentsline{toc}{section}{Spis rysunków}

\newpage

\pagestyle{headings}

\section{Wstêp}

S³owo „kryptografia” pochodzi z jêzyka greckiego i mo¿e byæ przet³umaczone jako „ukryte pismo”. Kryptografia pocz¹tkowo opiera³a siê na tajnoœci sposobu przekazywania informacji oraz na steganograficznych sposobach zapisywania informacji w tekstach lub grafikach w taki sposób, aby nawet osoba przewo¿¹ca wiadomoœci nie wiedzia³a, ¿e przewozi jak¹œ tajn¹ wiadomoœæ. Obecnie kryptografia zajmuje siê przekszta³ceniem wiadomoœci w taki sposób, aby sta³a siê niemo¿liwa do odczytania bez u¿ycia specjalnego tajnego klucza \cite{KryptografiaAsymetrczna1}.

Przekszta³cona w powy¿szy sposób wiadomoœæ nazywana jest szyfrogramem lub krypotogramem, a ca³y proces nazywany jest szyfrowaniem.

W dzisiejszych czasach wiadomoœci wysy³ane, przetwarzane i odczytywane s¹ przy pomocy komputerów lub innych urz¹dzeñ elektronicznych. Kryptografia w kontekœcie dnia dzisiejszego nie zajmuje siê zatem tylko szyfrowaniem tekstów, ale mo¿e byæ równie¿ i jest stosowania do szyfwowania wszelakich informacji przetwarzanych przez systemy komputerowe, takich jak: teksty, obrazy, klipy wideo, muzyka. Dane w systemach komputerowych przechowywane s¹ w postaci cyfrowej i ka¿de takie dane mog¹ byæ zaszyfrowane.

Wspó³czesn¹ kryptografie mo¿na podzieliæ na:
\begin{itemize}
	\item symetryczn¹ - do szyfrowania i deszyfrowania u¿ywany jest ten sam klucz,
	\item asymetryczn¹ - do szyfrowania i deszyfrowania u¿ywane s¹ ró¿ne klucze.
\end{itemize}

Kryptografia nie zajmuje siê jednak tylko szyfrowaniem. Poza szyfrowaniem, czyli poufnoœci¹ metody krypograficzne mog¹ zapewniæ:

\begin{itemize}
	\item integralnoœæ - niezmiennoœæ danych w czasie procesu,
	\item uwierzytelnianie - autentycznoœæ, pewnoœæ co do pochodzenia danych,
	\item niezaprzeczalnoœæ - nadawca nie mo¿e siê wyprzeæ przes³ania komunikatu o ustalonej treœci.
\end{itemize}

Powy¿sze cechy mog¹ byæ dostarczone przy pomocy podpisu cyfrowego. Podpis cyfrowy to dodadkowa informacja do³¹czona do danych s³u¿aca do weryfikacji ich Ÿród³a, oraz zapewniaj¹ca integralnoœæ, autentycznoœæ i niezaprzeczalnoœæ. Podpisy cyfrowe korzystaj¹ z kryptografii asymetrycznej - tworzona jest para kluczy:

\begin{itemize}
	\item klucz prywatny - s³u¿¹cy do podpisywania wiadomoœci,
	\item klucz publiczny - s³u¿¹cy do weryfikacji wiadomoœci.
\end{itemize}

Ponadto domen¹ kryptografii s¹ takie zagadnienia jak:

\begin{itemize}
	\item dowód z wiedz¹ zerow¹,
	\item g³osowanie elektroniczne,
	\item wspó³dzielenie tajemnic,
	\item obliczenia wielopodmiotowe.
\end{itemize}

Kolejnym zagadnieniem bêd¹cym przedmiotem tej pracy s¹ „systemy rozproszone”. Ze wzglêdu na ró¿norodnoœæ rozwa¿anych aspektów nie istnieje jednolita definicja systemu rozproszonego. Definicja ta ewoluowa³a wraz z rozwojem komputerów oraz sieci komputerowych. Za system rozproszony uwa¿a siê powszechnie zbiór niezale¿nych urz¹dzeñ technicznych (np. komputerów) po³¹czonych w jedn¹, spójn¹ logiczn¹ ca³oœæ (np. przy pomocy sieci komputerowej).

Cechy systemów rozproszonych to\cite{SystemyRozproszone1}:
\begin{itemize}
	\item Ukrycie przed u¿ytkownikami systemu:
		\subitem - ró¿nic pomiêdzy poszczególnymi komputerami,
		\subitem - sposobów komunikowania siê komputerów,
		\subitem - wewnêtrznej organizacji systemu rozproszonego.
	\item Jednolity i spójny interfejs dla u¿ytkownika - niezale¿nie od czasu i miejsca interakcji.
\end{itemize}

Systemy rozproszone s¹ tworzone ze wzglêdu na istotne potencjalne zalety tych systemów. Efektywne zagospodarowanie tych zalet mo¿e sprawiæ, ¿e bêd¹ one bardziej atrakcyjne dla u¿ytkownika koñcowego ni¿ systemy scentralizowane\cite{SystemyRozproszone1}.

Nastêpnym elementem wystêpuj¹cym w temacie, a tak¿e bêd¹cym nieod³¹czym elementem tego opracowania jest „wieloplatformowoœæ”. Wieloplatformowoœæ jest to cecha systemu lub aplikacji, który dzia³a na wiêcej ni¿ jednej platformie. Platforma to kombinacja sprzêtu i oprogramowania, na której uruchamiana jest aplikacja lub system. Platforma sprzêtowa mo¿e odnosiæ siê do architektury procesora lub architektury komputera. Platforma systemowa odnosi siê do systemu operacyjnego lub maszyny wirtualnej, mo¿e byæ tak¿e kombinacj¹ obydwu. U¿ytkownik stosuje okreœlony program po to, aby zrealizowaæ konkretne zadanie. Tak d³ugo, dopó³ki funkcjonowanie aplikacji nie zale¿y od platformy w której siê wykonuje, dla u¿ytkownika jest ca³kowicie obojêtne na jakiej platformie jest uruchamiana. Platforma sprzêtowa i programowa stanowi¹ jedynie œrodowisko dla uruchamiania systemów i aplikacji, same w sobie bez oprogramowania s¹ bezu¿yteczne.

\newpage

\subsection{Cel pracy}

Celem pracy jest zaprojektowanie, zaimplementowanie oraz wdro¿enie systemu komputerowego umo¿liwiaj¹cego bezpieczn¹ komunikacjê u¿ytkowników oraz cyfrowe podpisywanie plików, a tak¿e weryfikacjê cyfrowo podpisanych plików. Dla uzyskania wiêkszego bezpieczeñstwa generowanie klucza dla podpisu cyfrowego oraz podpisywanie plików bêdzie rozproszone, a wiêc odbywaæ siê ono bêdzie w kilku miejscach systemu.

Wynikiem pracy bêdzie system rozproszony, którego u¿ytkownicy koñcowi bêd¹ mogli z niego korzystaæ pracuj¹c na ró¿nych platformach sprzêtowych i programowych. Sam system bêdzie zaprojektowany równie¿ w taki sposób, aby przy mo¿liwie ma³ych zmianach lub bez nich móg³ byæ uruchamiany na ró¿nych platformach.
W pracy zostan¹ przeprowadzone testy aplikacji oraz zastosowanych mechanizmów kryptograficznych.

\subsection{Zakres pracy}

Pierwszym elementem pracy jest zaprojektowanie i zaimplementowanie aplikacji dzia³aj¹cej na serwerze, która funkcjonowaæ bêdzie jako punkt dostêpowy dla u¿ytkowników systemu czyli klientów. Kolejnym elementem bêdzie mediator, bêdzie to czêœæ systemu, która bêdzie uczestniczyæ przy generowaniu klucza dla podpisu cyfrowego oraz bêdzie bra³a udzia³ przy podpisywaniu plików. Klienci chc¹cy korzystaæ z systemu bêd¹ musieli posiadaæ aplikacje klienck¹, która bêdzie kolejnym elementem systemu. Administratorzy bêd¹ posiadali specjaln¹ wersjê klienta, za pomoc¹ której bêdzie mo¿na dodawaæ, edytowaæ lub usuwaæ u¿ytkowników systemu.

\newpage

\section{Analiza wymagañ i za³o¿enia projektowe}

W niniejszym rozdziale zawarto analizê wymagañ funkcjonalnych i niefunkcjonalnych oraz za³o¿enia stawiane przed systemem.

\subsection{Koncepcja dzia³ania systemu}

W sk³ad systemu wchodz¹ nastêpuj¹ce komponenty:

\begin{itemize}
	\item Serwer Dostêpowy,
	\item Mediator,
	\item Klient,
	\item Administrator Klient.
\end{itemize}


G³ównym wêz³em systemu jest \texttt{serwer dostêpowy}. Serwer ten przechowuje informacje o zarejstrowanych u¿ytkownikach systemu w bazie danych oraz implementuje logikê biznesow¹. Serwer ten jest punktem dostêpowym do którego przy pomocy aplikacji klienckiej ³¹cz¹ siê u¿ytkownicy.

U¿ytkownik koñcowy przy dostêpie do systemu korzysta z aplikacji \texttt{Klient}, która oferuje graficzny interfejs u¿ytkownika. Aplikacja kliencka komunikuje siê bezpoœrednio jedynie z serwerem dostêpowym. Aplikacja \texttt{Klient} umo¿liwia wymianê wiadomoœci z innymi u¿ytkownikami systemu, a tak¿e podpisywanie cyfrowe plików oraz weryfikacjê podpisów cyfrowych.

 \texttt{Mediator} jest to osobny serwer, a zarazem wêze³ systemu, który bierze udzia³ podczas generowania kluczy dla podpisu cyfrowego, a tak¿e podczas procesu podpisywania pliku.  \texttt{Mediator} posiada w³asn¹ bazê danych, w której przechowuje swoje czêœci kluczy prywatnych u¿ytkowników.

\texttt{Administrator Klient} to aplikacja, dziêki której mo¿na dodawaæ, edytowaæ i usuwaæ u¿ytkowników systemu. Komunikuje siê ona bezpoœrednio z \texttt{serwerem dostêpowym}.

\newpage

\subsubsection{Komponenty systemu}

\begin{figure}[h!]
\begin{center}
\includegraphics[width=0.8\textwidth]{system.pdf}
\end{center}
\caption{Kierunek wywo³ywania komponetów systemu.} \label{system1}
\end{figure} 

\newpage

\subsection{Wymagania funkcjonalne}

Wymagania funkcjonalne dla systemu to:
\begin{itemize}
	\item Mo¿liwoœæ dostêpu do systemu jedynie po pomyœlnym zalogowaniu.
	\item Oprócz \texttt{nazwy u¿ytkownika} i \texttt{has³a}, system przydziela ka¿demu u¿ytkownikowi specjalny \texttt{klucz serwisowy}, który u¿ywany jest przy komunikacji pomiêdzy \texttt{serwerem dostêpowym} a \texttt{aplikacj¹ klienck¹} oraz pomiêdzy \texttt{serwerem dostêpowym} a \texttt{mediatorem} oraz s³u¿y jako dodadkowy element walidacji.
	\item Wymiana \texttt{wiadomoœci tekstowych} z innymi \texttt{u¿ytkownikami} w trybie rzeczywistym poprzez sieæ internet.
	\item Dostêpna \texttt{lista kontaktów} z mo¿liwoœci¹ modyfikacji, czyli:
		\subitem - dodawanie nowego kontaktu,
		\subitem - edytowanie kontaktu,
		\subitem - usuwanie kontaktu.
	\item Przechowywanie \texttt{listy u¿ytkowników} lokalnie w \texttt{pliku XML}.
	\item Przechowywanie \texttt{konfiguracji klienta} w lokalnym \texttt{pliku konfiguracyjnym}.
	\item Powiadomienie o otrzymaniu nowej \texttt{wiadomoœci} od innego \texttt{u¿ytkownika} systemu.
	\item Wyœwietlanie \texttt{statusu kontaktów}:
		\subitem - \texttt{online},
		\subitem - \texttt{offline}.
	\item Generowanie \texttt{kluczy} dla \texttt{podpisu cyfrowego}:
	\item Generowanie \texttt{kluczy} wymaga ponownej autoryzacji (podanie \texttt{loginu} i \texttt{has³a})
	\item Podczas generowania \texttt{klucz prywatny} dzielony jest na dwie czêœci:
		\subitem - \texttt{czêœæ prywatna u¿ytkownika} - przechowywan¹ przez \texttt{aplikacje klienck¹},
		\subitem - \texttt{czêœæ prywatna mediatora} - przechowywan¹ w \texttt{mediatorze}.
	\item Cyfrowe \texttt{podpisywanie plików}.
	\item \texttt{Podpisywanie pliku} odbywa siê dwuetapowo. Pierwszy etap odbywa siê w \texttt{aplikacji klienckiej}, za pomoc¹ \texttt{czêœci prywatnej klucza u¿ytkownika}. Czêœciowy \texttt{podpis} finalizowany jest przez \texttt{mediator} za pomoc¹ \texttt{czêœci prywatnej klucza mediatora}.
	\item Weryfikacja \texttt{podpisanego pliku}.
	\item Weryfikacja odbywa siê po stronie \texttt{aplikacji klienckiej}.
	\item Osobna aplikacja \texttt{klient do administracji} do zarz¹dzania systemem posiadaj¹ca nastêpuj¹ce funkcjonalnoœci:
	\subitem - dodawanie \texttt{u¿ytkownika systemu},
	\subitem - edytowanie \texttt{u¿ytkownika systemu},
	\subitem - kasowanie \texttt{u¿ytkownika systemu}.
\end{itemize}


\newpage

\subsubsection{Diagram przypadków u¿ycia}

\begin{figure}[h!]
\begin{center}
\includegraphics[width=0.8\textwidth]{useCase.pdf}
\end{center}
\caption{Diagram przypadków u¿ycia.} \label{useCase1}
\end{figure} 

\newpage

\subsubsection{Scenariusze wybrancyh przypadków u¿ycia}
W rozdziale tym przedstawione zosta³y wybrane scenariusze przypadków u¿ycia.
\\
\textbf{Scenariusz do przypadku u¿ycia: \textit{Generuj parê kluczy}}\\
\\
\\
\begin{tabular}{|p{12cm}|}
\hline
\textbf{Warunki pocz¹tkowe}
\begin{enumerate}
	\item System jest poprawnie skonfigurowany i dzia³a prawid³owo.
	\item \texttt{U¿ytkownik} ma uruchomionego \texttt{klienta} i jest zalogowany do systemu oraz posiada swój w³asny unikalny \texttt{klucz serwisowy}.
\end{enumerate}\\
\hline
\textbf{G³ówny ci¹g zda¿eñ}
\begin{enumerate}
	\item \texttt{U¿ytkownik} przechodzi do zak³adki \texttt{konfiguracja}.
	\item \texttt{U¿ytkownik} klika w przycisk \texttt{zarz¹daj now¹ parê kluczy}.
	\item \texttt{U¿ytkownik} podaje prawid³owy \texttt{login} i \texttt{has³o}, a nastêpnie klika w przycisk \texttt{generuj klucze}.
	\item Zostaje wys³ane ¿¹danie do \texttt{serwera dostêpowego} o wygenerowanie nowej \texttt{pary kluczy}.
	\item \texttt{Para kluczy} zostaje wygenerowana. \texttt{Klucz prywatny} zostaje podzielony pomiêdzy \texttt{mediatorem} i \texttt{u¿ytkownikiem}.
	\item Zostaje wyœwietlona informacja o \texttt{kluczu} oraz jego poprawnym wygenerowaniu.
\end{enumerate}\\
\hline
\textbf{Scenariusz alternatywny}
\begin{enumerate}
	\item \texttt{U¿ytkownik} podaje nieprawid³owy \texttt{login} lub \texttt{has³o}.
	\item Po wciœniêciu przycisku \texttt{generuj klucze} zostaje wyœwietlony komunikat o b³êdzie.
\end{enumerate}\\
\hline
\textbf{Scenariusz alternatywny 2}
\begin{enumerate}
	\item Któryœ z wêz³ów systemu: \texttt{mediator} lub \texttt{serwer dostêpowy} s¹ niedostêpne.
	\item Po wciœniêciu przycisku  \texttt{generuj klucze} zostaje wyœwietlony komunikat o b³êdzie.
\end{enumerate}\\
\hline
\end{tabular}

\newpage

\textbf{Scenariusz do przypadku u¿ycia: \textit{Podpisz plik}}\\
\\
\\
\begin{tabular}{|p{14cm}|}
\hline
\textbf{Warunki pocz¹tkowe}
\begin{enumerate}
	\item System jest poprawnie skonfigurowany i dzia³a prawid³owo.
	\item \texttt{U¿ytkownik} ma uruchomionego \texttt{klienta} i jest zalogowany do systemu oraz posiada swój w³asny unikalny \texttt{klucz serwisowy}.
	\item \texttt{U¿ytkownik} wygenerowa³ \texttt{parê kluczy}, posiada swoj¹ czêœæ prywatn¹, a druga czêœæ znajduje siê na \texttt{mediatorze}.
\end{enumerate}\\
\hline
\textbf{G³ówny ci¹g zda¿eñ}
\begin{enumerate}
	\item \texttt{U¿ytkownik} przechodzi do zak³adki \texttt{podpis cyfrowy}.
	\item \texttt{U¿ytkownik} klika w przycisk \texttt{wczytaj plik}, a nastêpnie wskasuje plik, który ma zostaæ podpisany.
	\item \texttt{U¿ytkownik} klika w przycisk \texttt{podpisz plik}.
	\item \texttt{Aplikacja kliencka} sk³ada czêœciowy podpis.
	\item Zostaje wys³ane ¿¹danie do \texttt{serwera dostêpowego} o ¿¹danie podpisu.
	\item Zwrócony zostaje sfinalizowany podpis pliku
	\item \texttt{U¿ytkownik} dostaje informacjê o podpisie cyfrowym i ma mo¿liwoœæ jego zapisania.
\end{enumerate}\\
\hline
\textbf{Scenariusz alternatywny}
\begin{enumerate}
	\item Klucz prywatny u¿ytkownika nie jest kompatybilny z czêœci¹ prywatn¹ klucza mediatora, lub klucz zosta³ zablokowany.
	\item Po wciœniêciu przycisku  \texttt{podpisz plik} zostaje wyœwietlony komunikat o b³êdzie.
\end{enumerate}\\
\hline
\textbf{Scenariusz alternatywny 2}
\begin{enumerate}
	\item Któryœ z wêz³ów systemu: \texttt{mediator} lub \texttt{serwer dostêpowy} s¹ niedostêpne.
	\item Po wciœniêciu przycisku \texttt{podpisz plik} zostaje wyœwietlony komunikat o b³êdzie.
\end{enumerate}\\
\hline
\end{tabular}

\newpage

\textbf{Scenariusz do przypadku u¿ycia: \textit{Wyœlij wiadomoœæ}}\\
\\
\\
\begin{tabular}{|p{14cm}|}
\hline
\textbf{Warunki pocz¹tkowe}
\begin{enumerate}
	\item System jest poprawnie skonfigurowany i dzia³a prawid³owo.
	\item \texttt{U¿ytkownik} posiada na \texttt{liœcie kontaktów} \texttt{kontakt} do którego chce wys³aæ \texttt{wiadomoœæ}.
	\item \item \texttt{U¿ytkownik} ma uruchomionego \texttt{klienta} i jest zalogowany do systemu oraz posiada swój w³asny unikalny \texttt{klucz serwisowy}.
\end{enumerate}\\
\hline
\textbf{G³ówny ci¹g zda¿eñ}
\begin{enumerate}
	\item \texttt{U¿ytkownik} przechodzi do zak³adki \texttt{komunikator}.
	\item \texttt{U¿ytkownik} klika w \texttt{kontakt}, do którego chce wys³aæ \texttt{wiadomoœæ}, a nastêpnie w \texttt{oknie wiadomoœci} wpisuje \texttt{wiadomoœæ}.
	\item \texttt{U¿ytkownik} klika w przycisk \texttt{wyœlij wiadomoœæ}.
	\item \texttt{Wiadomoœæ} zostaje wys³ana do odbiorcy.
\end{enumerate}\\
\hline
\textbf{Scenariusz alternatywny}
\begin{enumerate}
	\item Któryœ z wêz³ów systemu: \texttt{mediator} lub \texttt{serwer dostêpowy} s¹ niedostêpne.
	\item Po wciœniêciu przycisku \texttt{podpisz plik} zostaje wyœwietlony komunikat o b³êdzie.
\end{enumerate}\\
\hline
\end{tabular}

\newpage

\subsection{Wymagania niefunkcjonalne}

Projektowany system musi spe³niaæ równierz szereg wymagañ niefunkcjonalnych, które zosta³y przedstawione w kolejnych podpunktach.

\subsubsection{Bezpieczeñstwo}

Kluczowym wymaganiem niefunkcjonalnym projektowanego systemu jest bezpieczeñstwo.

\begin{itemize}
	\item Komunikacja pomiêdzy \texttt{aplikacj¹ klienck¹}, a \texttt{serwerem dostêpowym} powinna byæ zaszyfrowana.
	\item \texttt{Mediator} nie powinien byæ dostêpny z sieci internet, ale powinien byæ umiejscowiony w sieci wewnêtrznej za firewallem i byæ dostêpny dla \texttt{serwera dostêpowego}.
	\item \texttt{Serwer dostêpowy} powinien zostaæ umiejscowiony w strefie zdemilitaryzowanej DMZ sieci lokalnej i byæ dostêpny z sieci internet oraz mieæ dostêp do \texttt{Mediatora}.
\end{itemize}

\subsubsection{Wykorzystywane œrodowiska, technologie i narzêdzia}

Z systemu powinni móc korzystaæ u¿ytkownicy niezale¿nie od systemu operacyjnego na którym pracuj¹. Sam system powinien móc byæ przy znikomych zmianach lub bez nich uruchomiony na innej platformie oraz wspó³pracowaæ z ró¿nymi bazami danych.

\begin{itemize}
	\item \texttt{Aplikacja kliencka} bêdzie napisana w technologii \texttt{Java SE 1.8}. Maszyna wirtualna Java dzia³a na systemach \texttt{Windows}, \texttt{Linux}, \texttt{Mac OS}, oraz na wielu platformach sprzêtowych.
	\item \texttt{Serwer dostêpowy} oraz \texttt{mediator} bêd¹ napisane w technologii \texttt{Java EE 1.8}. Aplikacje \texttt{Java EE} mo¿na uruchamiaæ na wielu platformach serwerowych, które pracuj¹ na ró¿nych platformach sprzêtowych i systemowych.
	\item Baza danych dla \texttt{serwera dostêpowego} i \texttt{mediatora} powinna byæ zdefiniowana w serwerze aplikacji.
	\item Do budowania wszystkich projektów u¿ywane bêdzie narzêdzie \texttt{Maven 3.3}.
	\item \texttt{Serwer dostêpowy} oraz \texttt{mediator} domyœlnie bêd¹ uruchamiane i testowane na serwerze aplikacji \texttt{Glassfish 4.1} oraz z baz¹ danych \texttt{MySql 5.7}.
	\item Komunikacja miêdzy elementami systemu bêdzie odbywaæ siê za pomoc¹ web serwisów typu \texttt{REST}.
	\item Wszystkie elementy ssytemu bêd¹ napisane przy pomocy zinegrowanego œrodowiska programistycznego \texttt{Eclipse JEE Mars 4.5.1}.
\end{itemize}

\subsubsection{Dostêpnoœæ}

\begin{itemize}
	\item Mo¿liwoœæ korzystania z systemu 7 dni w tygodniu 24h na dobê z wyj¹tkiem przerwy na zarz¹dzanie i konserwacjê (œrednio 5h w miesi¹cu).
	\item Mo¿liwoœc korzystania z systemu z sieci internet.
\end{itemize}

\subsubsection{Inne wymagania}

\begin{itemize}
	\item Legalne funkcjonowanie systemu bez zakupu licencji na dodadkowe oprogramowanie.
	\item System napisany modu³owo, umo¿liwiaj¹cy ³¹tw¹ modyfikacjê funkcjonalnoœci, rozszerzalnoœæ oraz ponowne u¿ycie kodu.
	\item \texttt{U¿ytkownik} powinien logowaæ siê do systemu jednoczeœnie tylko z jednej lokalizacji.
	\item \texttt{Aplikacja kliencka} posiada intuicyjny i estetyczny interfejs graficzny. 
\end{itemize}

\newpage

\section{Analiza zastosowanych metod i technologii}

W tym nieniejszym rozdziale omówione zastosta³y g³ówne pojêcia i technologie stosowane w systemie oraz metody wykorzystywane podczas jego tworzenia. W ostatnim podrozdziale przedstawiony zosta³ model matematyczny podpisu cyfrowego, na podstawie którego utworzona zosta³a implementacja w systemie.

\subsection{Aplikacja Enterprise}

Nie ma jednoznacznej definicji opisuj¹cej aplikacjê typu enterprise, istnieje jednak wiele cech i w³aœciwoœci, które charakteryzuj¹ aplikacje typu enterprise. S¹ to miêdzy innymi:

\begin{itemize}
	\item skalowalnoœæ – to w³aœciwoœæ, która charakteryzuje system przygotowany na wzrost liczby u¿ytkowników zarówno pod wzglêdem architektonicznym (rozszerzalnoœæ kodu) jak i wydajnoœciowym(np. load balancing),
	\item podzia³ na warstwy, istniej¹ ró¿ne podzia³y, jednak zazwyczaj mo¿na wyró¿niæ:
		\subitem - warstwê klienta,
		\subitem - warstwê prezentacji,
		\subitem - warstwê biznesow¹,
		\subitem - warstwê integracji,
		\subitem - warstwê zasobów; 
	\item bezpieczeñstwo - system powinien byæ odporny na ataki z zewn¹trz oraz spe³niaæ aktualnie przyjête normy bezpieczeñstwa,
	\item modularnoœæ - elementy systemu powinne byæ pogrupowane w modu³y,
	\item oddzielenie komponentów technicznych oraz logiki biznesowej,
	\item wysoce skompikowane systemy implementowane i wdra¿ane przez wiele lat,
	\item odpornoœæ na awarie - uzyskan¹ np. poprzez redundancjê krytycznych elementów systemu,
	\item systemy rozproszone,
	\item ³atwoœæ odzyskiwania po awarii - uzyskan¹ np. poprzez automatyczne i regularne tworzenie kopii zapasowych aktualnego stanu aplikacji.
\end{itemize}

\subsubsection{Technologie Java Enterprise Edition}

Java EE lub inaczej Java Enterprise Edition jest to platforma programistyczna jêzyka Java s³u¿¹ca do pisania aplikacji biznesowych. Java EE posiada wszystkie elementy oraz zalety platformy Java SE, dziêki czemu jest w pe³ni przenoœna i mo¿e byæ implementowana oraz wdra¿ana na dowolnym systemie operacyjnym posiadaj¹cy wirtualn¹ maszynê Javy (JVM). Jave EE rozszerza wersje SE o zbiór komponentów przeznaczonych do tworzeniaw aplikacjach klasy enterprise.
Komponenent Javy EE jest niezale¿n¹, funkcjonaln¹ jednostk¹ oprogramowania wbudowywan¹ w aplikacjê JEE (wraz z powi¹zanymi z nim klasami i plikami) i komunikuj¹c¹ siê z innymi komponentami\cite{JavaEE6Przewodnik1}. Java EE 7 wprowadzi³a szereg adnotacji, dziêki którym zbêdne staje siê przechowywanie du¿ej czêœci konfiguracji w plikach XML.

W specyfikacji Javy EE zdefiniowano nastêpuj¹ce komponenty\cite{JavaEE6Przewodnik1}:

\begin{itemize}
	\item aplikacje klienckie i aplety s¹ komponentami uruchamianymi po stronie klienta,
	\item komponenty technologii Java Servlet, JavaServer Faces oraz JavaServer Pages (JSP) s¹ komponentami webowymi dzia³aj¹cymi na serwerze,
	\item komponenty Enterprise JavaBeans (zwane tak¿e ziarnami EJB) bêd¹ce komponentami biznesowymi dzia³aj¹cymi na serwerze.
\end{itemize}
  
Warstwy aplikacji zosta³y przedstawione na rysunku \ref{jee1}.

\newpage

\begin{figure}[h!]
\begin{center}
\includegraphics[width=0.8\textwidth]{jee.png}
\end{center}
\caption{Wielowarstwowa aplikacja w technologii Java EE\cite{JavaEETutorial1}.} \label{jee1}
\end{figure}

\newpage

\subsubsection{Serwer i kontenery Java EE}

Aplikacja Java EE uruchamiana jest na serwerze Javy EE. Serwery aplikacji Javy EE to np:

\begin{itemize}
	\item Apache Geronimo,
	\item GlassFish,
	\item JBoss Application Server,
	\item ObjectWeb JOnAS,
	\item IBM WebSphere Application Server,
	\item Oracle WebLogic Server,
	\item Oracle AS/OC4J (nierozwijany, porzucony na rzecz WebLogic Server),
	\item SAP Web Application Server.
\end{itemize}

Serwer Javy EE zawierea kontenery przeznaczone do przechowywania oraz uruchamiania poszczególnych czêœci aplikacji. Na rysunku \ref{jeeContainer1} zosta³y przedstawiony zosta³ serwer Javy EE oraz osadzone na nim kontenery.

\begin{itemize}
	\item Serwer Javy EE - œrodowisko uruchomieniowe dla aplikacji JEE. Serwer Javy EE dostarcza kontenery EJB oraz kontenery webowe.
	\item Kontener Enterprise JavaBeans(EJB) - zarz¹dza wykonywaniem ziaren EJB w aplikacjach JEE. Komponenty EJB i ich kontener dzia³aj¹ na serwerze Javy EE.
	\item Kontener webowy - zarz¹dza dzia³aniem stron internetowych, serwletów i niektórych komponentów EJB aplikacji JEE. Komponenty webowe i ich kontener dzia³aj¹ na serwerze Javy EE
	\item Kontener aplikacji klienckich - zarz¹dza dzia³aniem komponentów aplikacji klienckiej. Aplikacje klienckie i ich kontener dzia³aj¹ po stronie klienta.
\end{itemize}

\newpage

\begin{figure}[h!]
\begin{center}
\includegraphics[width=0.8\textwidth]{jeeContainer.png}
\end{center}
\caption{Serwer i kontenery Javy EE\cite{JavaEETutorial1}.} \label{jeeContainer1}
\end{figure}

\newpage

\subsubsection{Enterprise JavaBeans}

Komponenty EJB (Enterprise JavaBeans) zwane tek¿e ziarnami EJB, s¹ fragmentami kodu zawieraj¹cymi pola oraz metody implementuj¹ce czêœæ logiki biznesowej. Komponenty EJB umo¿liwiaj¹ tworzenie i wdra¿anie rozproszonych aplikacji na bazie komponentów, które oferuj¹ skalowalnoœæ, mo¿liwoœc przetwarzania transakcyjnego i bezpieczeñstwo.
Za zarz¹dzanie instancj¹ komponentu w czasie wykonywania odpowiada kontener. Klient uzyskuje dostêp do komponentu za poœrednictwem kontenera, w którym dany komponent zosta³ wdro¿ony. Klient mo¿e te¿ dzia³aæ po stronie serwera i mieæ na przyk³ad postaæ komponentu zarz¹dzalnego, komponentu CDI lub serwletu\cite{JavaEE6Leksykon1}.

Istniej¹ trzy rodzaje komponentów EJB:

\begin{itemize}
	\item komponenty sesyjne, które dzielone na:
		\subitem - stanowe - ka¿dy komponent przechowuje unikalny stan, np. stan komunikacji z klientem;
		\subitem - bezstanowe - komponenty te wbrew nazwie te¿ posiadaj¹ swój unikalny stan, jednak nie mo¿e byæ on powi¹zany bezpoœrednio z ¿¹daniem, na które mo¿e zostaæ zwrócony inny komponent tego samego typu.
		\subitem - singletony - unikalne komponent na skalê œrodowiska uruchomieniowego, przechowuj¹ce np stan aplikacji;
	\item komponenty sterowane komunikatami - komponenty wykorzystywane podczas komunikacji w technologii JMS;
	\item komponenty encyjne - komponenty przechowuj¹ce encje danych, od wersji EJB 3.0 oznaczone s¹ jako przestarza³e, a do przechowywania encji zaleca siê stosowanie klaz z adnotacj¹ @Entity.
\end{itemize}

\subsubsection{Mapowanie obiektowo-relacyjne}

Mapowanie obiektowo-relacyjne (ORM) jest to sposób odwzorowania obiektowej architektury systemu informatycznego na bazê danych (lub inny element systemu) o relacyjnym charakterze. Implementacja takiego odwzorowania stosowana jest m.in. w przypadku, gdy tworzony system oparty jest na podejœciu obiektowym, a system bazy danych operuje na relacjach. 

JavaPersistence API (JPA) jest standardem ORM dla jêzyka Java. Z punktu widzenia programisty jest to mo¿liwoœæ operowania na obiektach - zwanych encjami - oraz zapisywania wyników operacji do relacyjnej bazy danych za pomoc¹ obiektu EntityManager. Sposób w jaki obiekty i ich po³¹czenia przek³adaj¹ siê na elementy bazy danych s¹ definiowane za pomoc¹ adnotacji lub dokumentów XML. Poza standardowym zestawem operacji udostêpnianych przez obiekt EntityManager standard JPA definiuje jêzyk zapytañ JPA Query Language podobny do SQL.\cite{Wikipedia1}. Encje w JPA oznaczane s¹ adnotacj¹ @Entity.

\subsection{Us³ugi sieciowe typu REST}

REST to akronim od representational state transfer. REST jest us³ug¹ sieciow¹ zaimplementowan¹ na bazie protoko³u HTTP. REST to te¿ architektura, która okreœla model i zasady umo¿liwiaj¹ce budowanie rozwi¹zañ, które pozwalaj¹ na bardzo du¿¹ skalowalnoœæ, wydajnoœæ i ³atwoœæ modyfikacji. W architekturze REST dane i funkcjonalnoœæ reprezentowane s¹ jako zasób. Ka¿dy zasób reprezentowany jest przez oddzielny URL. Rest oprócz zasobów reprezentowanych przez Uri to równie¿ kwestia reprezentacji - dany zasób mo¿e byæ reprezentowany jako wynik typu XML, Json, Text, Html, Image oraz wiele innych typów. Komunikacja REST jest bezstanowa. Us³ugi inaczej web serwisy typu REST nazywane s¹ te¿ serwisami RESTful.

Us³ugi REST korzystaj¹ zazwyczaj z 4 metod. Metody te to:

\begin{itemize}
	\item Get - u¿ywana przy dostêpie do zasobu,
	\item Put - u¿ywana przy tworzeniu zasobu oraz przy innych operacjach,
	\item Update - u¿ywana przy aktualizacji zasobu,
	\item Delete - u¿ywana do kasowania zasobu.
\end{itemize}

\subsubsection{Interfejs JAX-RS oraz implementacja Jersey}

JAX-RS (od ang. Java API for RESTful web services) to API jêzyka Java, które powsta³o w celu u³atwienia tworzenia aplikacji opartych o architekturê REST. Od wersji 2.0 JAX-RS definiuje interfejs sterowany adnotacjami. Adnotacje JAX-RS s¹ adnotacjami œrodowiska uruchomieniowego Java EE. Po uruchomieniu w kontenerze Java EE w œrodowisku uruchomieniowy zostaj¹ wygenerowane klasy pomocnicze oraz artefakty niezbêdne do dzia³ania web serwisu, nastêpnie us³uga jest automatycznie konfigurowana, po czyn zostaje udostêpniona\cite{JavaEE6Przewodnik1}.

JAX-RS oferuje miêdzy innymi nastêpuj¹ce adnotacje:

\begin{itemize}
	\item @Path - jest wzglêdn¹ œcie¿k¹ URI wskazuj¹c¹ miejsce hostowania klasy Javy,
	\item @GET - metody oznaczone tym desygnatorem bêd¹ obs³ugiwa³y ¿¹dania GET,
	\item @POST - metody oznaczone tym desygnatorem bêd¹ obs³ugiwa³y ¿¹dania POST,
	\item @PUT - metody oznaczone tym desygnatorem bêd¹ obs³ugiwa³y ¿¹dania PUT,
	\item @DELETE - metody oznaczone tym desygnatorem bêd¹ obs³ugiwa³y ¿¹dania DELETE,
	\item @HEAD - metody oznaczone tym desygnatorem bêd¹ obs³ugiwa³y ¿¹dania HEAD,
	\item @PathParam - adnotacj¹ ta s³u¿y do wyekstrahowania parametru z URI. nazwy parametrów odpowiadaj¹ nazwom zmiennych okreœlonych we wzorcu URI;
	\item @QueryParam - adnotacj¹ ta s³u¿y do wyekstrahowania parametru z URI, parametry zapytania s¹ ekstrahowane z parametrów zapytania adresu URI;
	\item @Consumes - u¿ywana do okreœlenia przetwarzanych przez zasób typów MIME,
	\item @Produces - u¿ywana do okreœlenia zwracanych przez zasób tymów MIME
	\item @Provider - adnotacj¹ t¹ oznacza siê wszystkie elementy, które mog¹ byæ potrzebne w œrodowisku uruchomieniowym.
\end{itemize}

Istnieje szereg dalszych adnotacji np: @MatrixParam, @HeaderParam, @CookieParam, @FormParam, @DefaultValue, @Context.

Jersey jest to referencyjna implementacja JAX-RS w Javie. Jersey to framework o otwartym Ÿródle, oferuj¹cy równie¿ szereg funkcjonalnoœcy wykraczaj¹cych poza standardowe API JAX-RS np. implementacjê klienta REST.

\subsubsection{Asynchronicznoœæ i Long Pooling}

Typowe ¿¹dania typu REST przetwarzane s¹ w trybie synchronicznym tzn. klient wysy³a ¿¹danie, serwer je przetwarza i zwraca odpowied¿. ¯¹dania synchroniczne stosuje siê wtedy gdy reprezentowany przez URI zasób mo¿e byæ odrazu zwrócony.
W przypadku gdy zasób nie jest odrazu dostêpny, lub jego przygotowanie trwa zbyt d³ugo ¿¹danie synchroniczne zakoñæzy siê niepowodzeniem.
W takim przypadku nale¿y stosowaæ ¿¹dania asynchroniczne. Przetwarzanie asynchroniczne polega na tym, ¿e serwer nie zwraca odrazu ¿¹dania, lecz przekazuje je do innego w¹tku, gdzie odpowiedŸ na ¿¹danie jest przygotowywana. Gdy zasób zostanie utworzony jest on zwracany do klienta.
Istnieje technika przetwarzania asynchronicznego, która nazywa siê Long Pooling. Polega ona na tym, ¿e klient wysy³a ¿¹danie do serwera. W przypadku gdy zasób nie jest dostêpny lub nie mo¿e zostaæ odrazu utworzony to ¿¹danie przechodzi w tryb oczekuj¹cy i zwrócone zostanie dopiero wtedy, gdy zasób bêdzie dostêpny. Technikê tak¹ stosuje siê np. w komunikatorach. Klient wysy³a ¿¹danie, które zwrócone zostanie dopiero wtedy, gdy inny klient wyœle do niego wiadomoœæ.

\newpage

\subsubsection{Filtry}

Interfejs JAX-RS oferuje szereg filtrów. Filtry mog¹ byæ stosowane np. w celu modyfikacji, odrzucenia, czy przekierowania ¿¹dania. Przy pomocy filtrów mo¿na np. uwierzytelniæ nadawcê ¿¹dania. Filtrowanie w w JAX-RS odbywa siê potokowo, tzn. mo¿na zdefiniowaæ kilka filtrów oraz ich kolejnoœæ. Filtry w JAX-RS dziel¹ siê na trzy grupy:

\begin{itemize}
	\item PreMatch Filters - s¹ to filtry które stosowane s¹ do ¿¹dania jescze przed dopasowaniem do danego zasobu.
 	\item Request Filters - filtry te stosowane s¹ po filtrach PreMatch oraz po tym jak ¿¹danie zosta³o dopasowane do zasobu, ale przed wykonaniem metody zasobu.
	\item Response Filters - s¹ to filtry, które stosowane s¹ do odpowiedzi na ¿¹danie. Filtry te stosowane s¹ po zakoñæzeniu metody zasobu, ale przed odes³aniem zasobu do klienta. Mog¹ operowaæ na danych zwróconych przez zasób.
\end{itemize}

Przetwarzanie potokowe filtrów w JAX-RS 2.0 zosta³o przedstawione na rysunku \ref{jaxrsPipeline1}.

\newpage

\begin{figure}[h!]
\begin{center}
\includegraphics[width=0.8\textwidth]{jaxrsPipeline.png}
\end{center}
\caption{Przetwarzanie potokowe filtrów w JAX-RS 2.0\cite{JaxRSFilters1} }\label{jaxrsPipeline1}
\end{figure} 

\newpage

\subsection{Podpis cyfrowy}

Podpis cyfrowy to matematyczny sposób sprawdzenia autentycznoœci danych elektronicznych. Zweryfikowany podpis cyfrowy oznacza, ¿e dane pochodz¹ od w³aœciwego nadawcy, który nie mo¿e zaprzeczyæ faktowi ich podpisania oraz, ¿e dane od momentu podpisu nie zosta³y zmienione. 

Podpis cyfrowy zapewnia nastêpuj¹ce funckcje bezpieczeñstwa:
\begin{itemize}
	\item autentycznoœci pochodzenia, która daje pewnoœæ co do autorstwa danych,
	\item niezaprzeczalnoœci, która utrudnia wyparcie siê autorstwa lub znajomoœci treœci danych,
	\item integralnoœci, która pozwala wykryæ nieautoryzowane modyfikacje danych po ich podpisaniu.
\end{itemize}

Dwa dominuj¹ce standardy podpisu cyfrowego to RSA oraz DSA.

W niniejszym opracowaniu rozpatrywany jest standard RSA. Jego nazwa pochodzi od pierwszych liter nazwisk jego twórców: Rivest, Shamir i Adleman. RSA oparty jest o kryptografiê asymetryczn¹. Bezpieczeñstwo szyfrowania opiera siê na trudnoœci faktoryzacji du¿ych liczb z³o¿onych.
W podpisie cyfrowym opartym o algorytm RSA stosuje siê klucz prywatny do podpisywania, oraz klucz publiczy do weryfikacji podpisu.

\subsubsection{Podpis cyfrowy z mediatorem}

Podpis elektroniczny z mediatorem to podpis cyfrowy, do którego z³o¿enia potrzebna jest dodadkowa zaufana strona zwana mediatorem. Klucz prywatny dzielony jest miêzy u¿ytkownikiem a mediatorem. Mediator bierze te¿ udzia³ przy generowaniu klucza prywatnego.

Generowanie klucza sk³ada siê z nastêpuj¹cych faz:

\begin{itemize}
	\item utworzenie przez dilera (generatora kluczy) pary kluczy, klucza prywatnego i publicznego,
	\item wys³anie do mediatora klucza publicznego oraz identyfikatora klucza,
	\item wygenerowanie przez mediator z modu³u klucza publicznego i identyfikatora klucza swojej czêœci klucza prywatnego i odes³ania go do dilera kluczy,
	\item obliczenie przez dilera kluczy czêœci prywatnej u¿ytkownika na podstawie czêœci klucza otrzymanego od mediatora i wygenerowanego w pierwszym punkcie klucza prywatnego
\end{itemize}

Z³o¿enie podpisu cyfrowego przy z pomoc¹ mediatora sk³ada siê z dwóch faz:

\begin{itemize}
	\item utworzenie czêœciowego podpisu po stronie u¿ytkownika, a nastêpnie wys³anie czêœciowego podpisu oraz podpisywanych danych do mediatora,
	\item podpisanie czêœciowego podpisu (finalizacja podpisu) przez stronê zaufan¹, czyli mediatora, a nastêpnie odes³anie podpisu do u¿ytkownika.
\end{itemize}

Weryfikacja podpisu odbywa identyczne jak w przypadku podpisu cyfrowego opartego o standardowy algorytm RSA w ca³oœci po stronie u¿ytkowniika.

\subsubsection{Model matematyczny i weryfikowanie podpisu}

\texttt{U¿ytkownik} posiadaj¹cy w systemie swój w³asny niepowtarzalny identyfikator \texttt{ID} oznaczony zostanie jako - \texttt{u}.

Dla ka¿dego \texttt{u} mo¿e zostaæ wygenerowana \texttt{para kluczy}:

\begin{itemize}
	\item \((d_u,N_u)\) -  \texttt{klucz prywatny},
	\item \((e_u,N_u)\) -  \texttt{klucz publiczny},
\end{itemize}

gdzie:

\begin{itemize}
	\item \((d_u)\) -  \texttt{eksponenta klucza prywatnego},
	\item \((e_u)\) -  \texttt{eksponenta klucza publicznego},
	\item \((N_u)\) -  \texttt{modu³} \texttt{klucza prywatnego} i  \texttt{klucza publicznego}.
\end{itemize}

\texttt{klucz prywatny} dzielony jest na dwie czêœci:

\begin{itemize}
	\item \((d_{K_u},N_u)\) - \texttt{czêœæ prywatna klucza} strony finalizuj¹cej podpis \texttt{mediatora},
	\item \((d_{M_u},N_u)\) - \texttt{czêœæ prywatna klucza} strony podpisuj¹cej \texttt{u¿ytkownika},
\end{itemize}

gdzie:

\begin{itemize}
	\item \(d_{K_u}\) - \texttt{czêœæ prywatna eksponenty} strony podpisuj¹cej \texttt{u¿ykownika},
	\item \(d_{M_u}\) - \texttt{czêœæ prywatna eksponenty} strony finalizuj¹cej podpis \texttt{mediatora}.
\end{itemize}

Eksponenty kluczy po podziale musz¹ spe³niaæ nastêpuj¹cy warunek:

\begin{itemize}
	\item \(d_u \equiv d_{K_u} + d_{M_u} \pmod{\varphi(N_u)} \),
\end{itemize}

gdzie:

\begin{itemize}
	\item \(\varphi\) - funkcja nosz¹ca nazwisko Eulera przypisuj¹ca ka¿dej liczbie naturalnej liczbê liczb wzglêdnie z ni¹ pierwszych nie wiêkszych od niej samej.
\end{itemize}

\texttt{Plik} -  \texttt{p} podpisany cyfrowo przez \texttt{u¿ytkownika} -  \texttt{u} ma postaæ:

\begin{itemize}
	\item \((p,h(p)^{d_u}\pmod{N_u}\),
\end{itemize}

gdzie:

\begin{itemize}
	\item \(h(p)\) - to skrót kryptograficzny \texttt{pliku} - \texttt{p} lub inaczej funkcja haszuj¹ca \texttt{pliku} - \texttt{p},
	\item \(h(p)^{d_u}\pmod{N_u}\) - to skrót \texttt{pliku} - \texttt{p} podniesiony do potêgi \(d_u\) modulo \(N_u\)
	\item \(h(p)^{d_u}\pmod{N_u}\equiv h(p)^{d_{K_u}}\pmod{N_u} \times  h(p)^{d_{M_u}}\pmod{N_u}\).
\end{itemize}

Aby zweryfikowaæ \texttt{cyfrowo podpisany plik} w postaci \((p,h(p)^{d_u}\pmod{N_u}\), nale¿y dysponowaæ \texttt{kluczem publicznym} \((e_u,N_u)\) \texttt{u¿ytkownika} - \texttt{u}.
W przypadku gdy do danego \texttt{klucza publicznego} dostarczony jest \texttt{certyfikat} - \texttt{c} ma on postaæ:

\begin{itemize}
	\item \((e_u,N_u,c_u)\).
\end{itemize}

Certyfikat \(c_u\) ma postaæ:

\begin{itemize}
	\item \((u,e_u,N_u,h(u,e_u,N_u)^{d_c}\pmod{N_c},e_c,N_c)\),
\end{itemize}

gdzie:

\begin{itemize}
	\item \(h(u,e_u,N_u)^{d_c}\pmod{N_c}\) to skrót \texttt{klucza publicznego} \texttt{u¿ytkownika} oraz \texttt{identyfikatora u¿ytkownika} podniesiony do potêgi \texttt{eksponênty klucza prywatnego certyfikatu} modulo \texttt{modu³ klucza publicznego certyfikatu} \(N_c\),
\end{itemize}

\texttt{Klucz publiczny} i \texttt{klucz prywatny} \texttt{certyfikatu} - \texttt{c} przechowywany jest w \texttt{urzêdzie certyfikuj¹cym}:

\begin{itemize}
	\item \(U_c\).
\end{itemize}

Weryfikacja \texttt{podpisu} nastêpuje w dwóch etapach. Pierwszy etap to sprawdzenie autentycznoœci \texttt{certyfikatu}. Nastêpuje to poprzez obliczenie skrótu z pierwszych trzech wartoœci \texttt{certyfikatu} \((u,e_u,N_u)\). Otrzymany w ten sposób skrót \(h(u,e_u,N_u)\) porównywany jest z wartoœci¹ \((h(u,e_u,N_u)^{d_c})^{e_c}\pmod{N_c}\), która jest czwart¹ czêœci¹ \texttt{certyfikatu} podniesion¹ do potêgi \(e_c\) modulo \(N_c\).
Je¿eli zachodzi równoœæ:

\begin{itemize}
	\item  \(h(u,e_u,N_u) = (h(u,e_u,N_u)^{d_c})^{e_c}\pmod{N_c}\).
\end{itemize}

Oznacza to, ¿e \texttt{certyfikat} pomyœlnie przeszed³ próbê autoryzacji. Autentycznoœæ \texttt{certyfikatu} implikuje autentycznoœæ  \texttt{klucza publicznego u¿ytkownika} - \texttt{u}. Umo¿liwia to weryfikacjê podpisu samego \texttt{pliku}:

\begin{itemize}
	\item \((u,p,h(p)^{d_u}\pmod{N_u}\).
\end{itemize} 

Weryfikacja \texttt{pliku} - {p} nastêpuje poprzez obliczenie \(h(p)\), a nastêpnie porównanie tej wartoœci z \((h(p)^{d_u})^{e_u}\pmod{N_u}\), gdzie \((h(p)^{d_u})^{e_u}\pmod{N_u}\) to  \(h(p)^{d_u}\pmod{N_u}\) podniesione do potêgi eksponenty \(e_u\) autoryzowanego \texttt{klucza publicznego} \((e_u,N_u)\) modulo \(N_u\).
Je¿eli zachodzi równoœæ:

\begin{itemize}
	\item \(h(p) = (h(p)^{d_u})^{e_u}\pmod{N_u}\),
\end{itemize} 

oznacza to, ¿e proces weryfikacji zakoñæzy³ siê pomyœlnie.
Je¿eli równoœæ ta nie zachodzi mo¿e oznacza to ¿e:

\begin{itemize}
	\item \texttt{plik} - \texttt{p} od momentu podpisu zosta³ zmieniony,
	\item \texttt{plik} - \texttt{p} zosta³ podpisany przy pomocy innego \texttt{klucza prywatnego},
	\item \texttt{klucz publiczny} nie nale¿y do \texttt{uzytkownika}, który podpisa³ plik.
\end{itemize} 

\texttt{Plik} mo¿e byæ równierz zweryfikowany bez \texttt{certyfikatu klucza publicznego}.

\subsubsection{Generowanie i podzia³ kluczy}

\texttt{U¿ytkownik} - \texttt{u} chc¹cy podpisaæ \texttt{plik} - \texttt{p} musi posiadaæ \texttt{parê kluczy}, która sk³ada siê z \texttt{klucza prywatnego} bior¹cego udzia³ przy sk³adaniu podpisu, oraz z \texttt{klucza publicznego}, który jest niezbêdny do weryfikacji podpisu.
Za generowanie kluczy odpowiedzialne jest \texttt{centrum generowania kluczy} lub inaczej \texttt{generator kluczy}. Generowanie kluczy przebiega nastêpuj¹co:

\begin{itemize}
	\item Wybierz losowo dwie du¿e liczby pierwsze  \(p\) i  \(q\) przy uwzglêdnieniu nastêpuj¹cych warunków:
		\subitem - liczby powinny mieæ zbli¿on¹ d³ugoœæ w bitach, ale jednoczeœnie powinny byæ od siebie odleg³e wartoœciami;
		\subitem - d³ugoœæ bitowa wartoœci \(p \times q\) powinna byæ równa lub zbli¿ona do d³ugoœci bitowej obliczanego klucza.
	\item Oblicz \( N = p \times q\). N jest \texttt{modu³em klucza publicznego} i \texttt{klucza prywatnego}.
	\item Oblicz  \(\varphi(N) = \varphi(p) \times \varphi(q) = (p - 1) \times (q - 1) = N - (p + q - 1)\).
	\item Wybierz losowo \(e \in \{1,2,3,...,\varphi(N)\}\) wzglêdnie pierwsze z \(\varphi(N)\) tzn. najwiêkszy wspólny dzielnik \(NWD(e,\varphi(N)) = 1\). Sk³adnik \(e\) jest \texttt{eksponent¹ klucza publicznego}.
	\subitem Zaleca siê aby wartoœæ \(e\) mia³a krótk¹ d³ugoœæ bitow¹, oraz ma³¹ wagê hamminga, tzn. sumê wartoœci ró¿nych od 0 w danym alfabecie, w tym przypadku \(alfabet = \{0,1\}\) (rozpatrywany jest zapis bitowy liczby). Typow¹ stosowan¹ wartoœci¹ jest np. \(e = 2^{16} + 1 = 65,537\).
	\item Oblicz eksponentê klucza prywatnego \(d \in \{1,2,3,...,\varphi(N)\}\) tak¹ ¿e:
	\subitem - wartoœæ \(d \equiv e^{-1}\pmod{\varphi(N)}\), lub inaczej \(d \times e = 1\pmod{\varphi(N)}\), tzn. wartoœæ \(d\) jest odwrotnoœci¹ modularn¹  \(e\).
	\item Wartoœci \(p\), \(q\) oraz \(\varphi(N)\) powinny zostaæ niejawne, poniewa¿ mog¹ one s³u¿yæ do obliczenia \(d\).
\end{itemize}

Z tak obliczonych wartoœci tworzy siê nastêpnie:

\begin{itemize}
	\item \((d,N)\) - \texttt{klucz prywatny},
	\item \((e,N)\) - \texttt{klucz publiczny}.
\end{itemize}

Po obliczeniu \texttt{pary kluczy}, \texttt{klucz prywtny} dzielony jest na dwie czêœci:

\begin{itemize}
	\item \((d_{M},N)\) - \texttt{czêœæ prywatna klucza} strony finalizuj¹cej podpis \texttt{mediatora},
	\item \((d_{K},N)\) - \texttt{czêœæ prywatna klucza} strony podpisuj¹cej \texttt{u¿ytkownika}.
\end{itemize}

Klucze maj¹ wspólny modu³, lecz ró¿ne eksponenty. Eksponenty te musz¹ spe³niaæ nastêpuj¹cy warunek:

\begin{itemize}
	\item \(d \equiv d_{K} + d_{M} \pmod{\varphi(N)} \).
\end{itemize}

Podzia³ \texttt{klucz prywtnego} odbywa siê w dwóch etapach. Najpierw generowana jest \texttt{czêœæ prywatna klucza} strony finalizuj¹cej podpis \texttt{mediatora}. Proces ten przebiega nastêpuj¹co:

\begin{itemize}
	\item \texttt{Centrum generowania kluczy} wysy³a do \texttt{mediatora} wygenerowany \texttt{klucz publiczny} oraz \texttt{identyfikator} \texttt{ID} \texttt{u¿ytkownika} - \texttt{u}, dla którego zosta³y wygenerowane \texttt{klucze}.
	\item \texttt{Mediator} posiada swoj¹ w³asn¹ parê kluczy znan¹ tylko jemu. Swoim kluczem prywatnym \((d_{m},N_m)\) \texttt{mediator} podpisuje \texttt{ID} \texttt{u¿ytkownika}. Podpis ten jest postaci \(h(ID)^{d_m}\pmod{N_m}\).
	\subitem  Podpis \(h(ID)^{d_m}\pmod{N_m}\) s³u¿y jako ziarno dla \texttt{generatora liczb pseudolosowych}.
	\item \texttt{Generator liczb pseudolosowych} o ziarnie \(h(ID)^{d_m}\pmod{N_m}\) losuje liczbê pseudolosow¹ \(d_{M}\), tak¹ ¿e:
	\subitem - d³ugoœæ bitowa liczby \(d_{M}\) to suma d³ugoœci bitowej \texttt{modu³u klucza publicznego} \(N\) przes³anego przez \texttt{Centrum generowania kluczy} oraz wartoœci \texttt{delta}, gdzie \(delta \in \{80...128\}\).
	\subitem - D³ugoœæ bitowa \(N\) mo¿e byæ obliczona jako \(floor(\log_2(N))+1\).
\end{itemize}

Liczby \((d_{M},N)\) tworz¹ \texttt{czêœæ prywatna klucza} strony finalizuj¹cej podpis \texttt{mediatora}. Liczba \(d_M\) wygenerowana w \texttt{mediatorze} odsy³ana jest nastêpnie do \texttt{centrum generowania kluczy}, gdzie na jej podstawie obliczana jest \texttt{czêœæ prywatna klucza} strony podpisuj¹cej \texttt{u¿ytkownika}. Odbywa siê to w nastêpuj¹cy sposób:

\begin{itemize}
	\item \(d_K = d - d_M \pmod{\varphi(N)}\).
\end{itemize}

Liczba \(d_K\) wraz z modu³em \(N\) tworz¹ \texttt{czêœæ prywatna klucza} strony podpisuj¹cej \texttt{u¿ytkownika} \((d_K,N)\).

\subsubsection{Podpis pliku}

\texttt{U¿ytkownik} - \texttt{u} ch¹cy podpisaæ \texttt{plik} - \texttt{p} oblicza skrót pliku \(h(p)\), a nastêpnie podnosi go do potêgi \(d_{K_u}\) modulo \(N_u\). Tak czêœciowo podpisany plik ma postaæ:

\begin{itemize}
	\item \(h(p)^{d_{K_u}}\pmod{N_u}\).
\end{itemize}

\texttt{U¿ytkownik} - \texttt{u} wysy³a do mediatora skrót \texttt{pliku} - \texttt{p} \(h(p)\) oraz czêœciowy podpis \(h(p)^{d_{K_u}}\pmod{N_u}\).

Mediator przy pomocy swojej czêœci klucza prywatnego podpisuje otrzymany skró\(h(p)\) otrzymuj¹c w ten sposób \(h(p)^{d_{_u}}\pmod{N_u}\), a nastêpnie mno¿y go z otrzymanym podpisem modulo \(N_u\). Po takiej operacji podpis jest kompletny i ma postaæ:

\begin{itemize}
	\item \(h(p)^{d_{K_u}}\pmod{N_u} \times  h(p)^{d_{M_u}}\pmod{N_u} = h(p)^{d_u}\pmod{N_u}\).
\end{itemize}

Podpis taki odsy³any jest do \texttt{u¿ytkownika} - \texttt{u}, który mo¿e do³¹czyæ go do \texttt{pliku} - \texttt{p}. Otrzymuj¹c podpisany plik w postaci:

\begin{itemize}
	\item \((p,h(p)^{d_u}\pmod{N_u})\).
\end{itemize}

\newpage

\section{Projekt systemu}
W niniejszym rozdziale zosta³ przedstawiony projekt systemu. W pierwszym podrozdziale przedstawiona zosta³a komunikacja oraz interakcjie pomiêdzy poszczególnymi elementami systemu. W kolejnych podrozdzia³ach przedstawione zosta³y projekty poszczególnych elementów systemu: \texttt{serwera dostêpowego},  \texttt{mediatora}, \texttt{klienta} oraz \texttt{klienta administratorskiego}.

\subsection{U¿ytkownicy systemu}

\texttt{Uzytkownik} w systemie mo¿e byæ przypisany do nastêpuj¹cych \texttt{ról}.

\begin{itemize}
	\item \texttt{U¿ytkownik standardowy} - posiada on standardow¹ funkcjonalnoœæ, przedstawion¹ w diagramie przypadku u¿ycia z wyj¹tkiem, z wy³¹czeniem dzia³añ administracyjnych, a wiêc zarz¹dzaniem \texttt{u¿ytkownikami} systemu.
	\item \texttt{Administrator} - posiada on funkcjonalnoœæ u¿ytkownika standardowego, a dodadkowo mo¿liwoœæ zarz¹dzania \texttt{u¿ytkownikami} systemu. \texttt{Administrator} ma mo¿liwoœæ logowania siê do systemu za poœrednictwem \texttt{aplikcji administratorskiej}.
\end{itemize}

\subsection{Projekt komunikacji pomiêdzy wêz³ami}

W podrozdziale tym przedstawiony zosta³ przebieg komunikacji pomiêdzy elementami systemu dla wybranych przypadków u¿ycia. Komunikacja w systemie odbywa siê za poœrednictwem web serwisów typu REST. W przypadku \texttt{logowania}, \texttt{wylogowywania} oraz \texttt{wysy³ania wiadomoœci} s¹ to zapytania synchroniczne. W przypadku \texttt{odbioru wiadomoœci}, \texttt{generowania klucza} oraz \texttt{podpisywania pliku} s¹ to zapytania asynchroniczne typu Long Pooling.
\texttt{Klient administratorski} u¿ywa zapytania asynchronicznego do pobrania listy u¿ytkowników. W przypadku gdy jakiœ wêze³ system jest niedostêpny \texttt{klient} systemu dostaje komunikat o b³êdzie.
W przypadku ³¹czenia siê \texttt{klientów} z sieci Internet, komunikacja pomiêdzy elementami systemu powinna byæ szyfrowana. Konfiguracja szyfrowania odbywa siê na serwerze Javy EE. Zaleca siê w³¹czenie szyfrowania za pomoc¹ protoko³u TLS. Nale¿y wtedy dostarczyæ \texttt{certyfikat serwera} lub taki wygenerowaæ.

\newpage

\subsubsection{Logowanie}

Logowanie to proces, który inicjuje \texttt{klient} systemu. Do zalogowania siê do systemu niezbêda jest znajomoœæ \texttt{loginu}, \texttt{has³a} oraz \texttt{klucza serwisowego}. Wszystkie te elementy dostarczane s¹ przez \texttt{administratora} po za³o¿eniu konta \texttt{u¿ytkownika} w systemie.
\texttt{Klient} wysy³a do \texttt{serwera dostêpowego} ¿¹danie zalogowania, a wraz z nim \texttt{u¿ytkownika}, \texttt{has³o} i \texttt{klucz serwisowy}, nastêpnie po pomyœlnym zautoryzowaniu \texttt{u¿ytkownika} na \texttt{serwerze dostêpowym} generowany jest unikalny \texttt{token}. \texttt{Token} dodawany jest do \texttt{listy tokenów}, a nastêpnie zwracany jest do \texttt{klienta}. Po otrzymaniu \texttt{tokena} w odpowiedzi REST \texttt{klient} zapisuje go. Od tego momentu \texttt{klient} jest zalogowany, a ka¿de nastêpne ¿¹danie, a¿ do wylogowania odbywa siê przy pomocy \texttt{klucza serwisowego} oraz \texttt{tokena} bez udzia³u \texttt{loginu} i \texttt{has³a}. Przy ¿adaniu wylogowania z systemu \texttt{serwer dostêpowy} usuwa z \texttt{token} z \texttt{listy tokenów}.
Diagramy na rysunkach \ref{logInActivity1} i \ref{LogIn1} przedstawij¹ proces logowania.

\newpage

\textbf{Diagram aktywnoœci dla logowania}\\

\begin{figure}[h!]
\begin{center}
\includegraphics[width=0.8\textwidth]{logInActivity.pdf}
\end{center}
\caption{Logowanie do systemu - diagram aktywnoœci.} \label{logInActivity1}
\end{figure}

\newpage

\textbf{Diagram sekwencji dla logowania}\\

\begin{figure}[h!]
\begin{center}
\includegraphics[width=0.7\textwidth]{LogIn.pdf}
\end{center}
\caption{Logowanie do systemu - diagram sekwencji.} \label{LogIn1}
\end{figure}

\newpage

\subsubsection{Wysy³anie wiadomoœci}

\texttt{U¿ytkownik} ma mozliwoœæ wysy³ania wiadomoœci tekstowych do innych \texttt{uzytkowników} systemu. Aby wys³aæ wiadomoœæ z \texttt{klienta} nale¿y byæ zalogowanym do systemu. \texttt{Klient} wysy³a ¿¹danie REST do \texttt{serwera dostêpowego}, w treœci którego znajduje siê \texttt{wiadomoœæ} a w nag³ówku \texttt{klucz serwisowy} oraz \texttt{token}. \texttt{Serwer dostêpowy} nastêpnie autoryzuje \texttt{u¿ytkownika} oraz sprawdza \texttt{listê nas³uchuj¹cych} \texttt{u¿ytkowników}. Je¿eli adresat wiadomoœci znajduje siê na tej liœcie to \texttt{serwer dostêpowy} przekazuje mu wiadomoœæ od nadawcy. Je¿eli u¿ytkownika nie ma na liœcie, to wiadomoœæ dodawana jest do \texttt{listy wiadomoœci} i bêdzie tam a¿ do chwili zalogowania siê adresata wiadomoœci do systemu, po czym zostanie mu przekazana. Na rysunkach \ref{sendMessageActivity1} i \ref{sendMessage1} zosta³ przedstawiony proces, który zachodzi po wys³aniu wiadomoœci z aplikacji \texttt{klienta}.

\newpage

\textbf{Diagram aktywnoœci dla wysy³ania wiadomoœci}\\

\begin{figure}[h!]
\begin{center}
\includegraphics[width=0.8\textwidth]{sendMessageActivity.pdf}
\end{center}
\caption{Wysy³anie wiadomoœci  - diagram aktywnoœci.} \label{sendMessageActivity1}
\end{figure}

\newpage

\textbf{Diagram sekwencji dla wysy³ania wiadomoœci}\\

\begin{figure}[h!]
\begin{center}
\includegraphics[width=0.7\textwidth]{sendMessage.pdf}
\end{center}
\caption{Wysy³anie wiadomoœci  - diagram sekwencji.} \label{sendMessage1}
\end{figure}

\newpage

\subsubsection{Odbiór wiadomoœci}

Odbiór wiadomoœci odbywa siê równie¿ przy pomocy asynchroniczneg zapytania REST. Po zalogowianiu \texttt{klient} wysy³a do \texttt{serwera dostêpowego} ¿¹danie odbioru \texttt{wiadomoœci} z nag³ówkiem zawieraj¹cym \texttt{klucz serwisowy} i \texttt{token}. Po pomyœlnej autoryzacji \texttt{serwer dotêpowy} sprawdza \texttt{listê wiadomoœci} w poszukiwaniu \texttt{wiadomoœci}, której adresat jest \texttt{u¿ytkownikiem} wysy³aj¹cym ¿¹danie. W przypadku znalezienia takiej wiadomoœci zostaje ona do³¹czona do odpowiedzi i jest zwracana do\texttt{klienta}. W przypadku, gdy na \texttt{liœcie wiadomoœci} nie ma ¿adnej wiadomoœci do \texttt{u¿ytkownika}, to ¿¹danie zapisywane jest na \texttt{liœcie nas³uchuj¹cych} i znajduje siê tam a¿ do chwili pojawienia siê \texttt{wiadomoœci} do \texttt{u¿ytkownika}. Ka¿de ¿¹danie wysy³aj¹ce wiadomoœæ sprawdza najpierw \texttt{listê nas³uchuj¹cych}. W chwili pojawienia siê na \texttt{serwerze dostêpowym} nowego ¿¹dania wys³ania \texttt{wiadomoœci} z \texttt{wiadomoœci¹} do \texttt{u¿ytkownika}, którego zapytanie znajduje siê na \texttt{liœcie nas³uchuj¹cych}, \texttt{wiadomoœæ} zostaje do³¹czona do ¿¹dania oczekuj¹cego, a ¿¹danie zostaje usuniête z \texttt{listy nas³uchuj¹cych} i jest odsy³ane do \texttt{klienta} jako odpowiedŸ na ¿¹dnaie asynchroniczne. Aplikacja \texttt{klient} po otrzymaniu odpowiedzi wyœwietla na \texttt{liœcie kontatków} obok \texttt{kontatku}, który jest adresatem \texttt{wiadomoœci} informacjê o nowej \texttt{wiadomoœci}. Proces w aplikacji \texttt{klient} do odbioru \texttt{wiadomoœci} uruchamiany jest jako osobny w¹tek w tle. Proces ten dzia³a w pêtli tak, ¿e po wysy³aniu ¿¹dania odbioru i otrzymaniu odpowiedzi wysy³a ponowne ¿¹danie odbioru \texttt{wiadomoœci}. Na rysunkach \ref{reciveMessageActivity1} i \ref{reciveMessage1} przedstawiony zosta³ proces odbioru wiadomoœci.

\newpage

\textbf{Diagram aktywnoœci dla odbioru wiadomoœci}\\

\begin{figure}[h!]
\begin{center}
\includegraphics[width=0.7\textwidth]{reciveMessageActivity.pdf}
\end{center}
\caption{Odbiór wiadomoœci  - diagram aktywnoœci.} \label{reciveMessageActivity1}
\end{figure}

\newpage

\textbf{Diagram sekwencji dla odbioru wiadomoœci}\\

\begin{figure}[h!]
\begin{center}
\includegraphics[width=0.7\textwidth]{reciveMessage.pdf}
\end{center}
\caption{Odbiór wiadomoœci  - diagram sekwencji.} \label{reciveMessage1}
\end{figure}

\newpage

\subsubsection{Generowanie pary kluczy}

Proces generowania kluczy odbywa siê w oparciu o model matematyczny przedstawiony w rozdziale 3. Nowe klucze generowane s¹ na ¿adanie \texttt{u¿ytkownika}. W aplikacji \texttt{klienckiej} ¿¹danie generowania \texttt{pary kluczy} to jedyne ¿¹danie oprócz logowania, które w celu dodadkowego zabezpieczenia, wymaga podania \texttt{loginu} i \texttt{has³a}. ¯¹danie generowania kluczy wysy³ane jest do \texttt{serwera dostêpowego}. Serwer po pomyœlnej autoryzacji \texttt{u¿ytkownika} generuje now¹ parê kluczy: \texttt{klucz publiczny} oraz \texttt{klucz prywatny}. \texttt{Klucz publiczny} oraz \texttt{klucz serwisowy} wysy³any jest nastêpnie do \texttt{mediatora}. \texttt{Mediator} na podstawie d³ugoœci bitowej \texttt{klucza publicznego}, w³asnego \texttt{klucza prywatnego} oraz wartoœci losowej generuje w oparciu o swój algorytm \texttt{prywatny klucz finalizuj¹cy}. Mediator zapisuje klucz publiczny \texttt{u¿ytkownika} oraz \texttt{prywatny klucz finalizuj¹cy}, nastêpnie \texttt{prywatny klucz finalizuj¹cy} odsy³any jest do \texttt{serwera dostêpowego}. Serwer na podstawie wczeœniej wygenerowanego \texttt{klucza prywatnego} oraz \texttt{prywatnego klucza finalizuj¹cego} oblicza \texttt{prywatny klucz u¿ytkownika}. \texttt{Para kluczy} sk³adaj¹ca siê z \texttt{Prywatnego klucz u¿ytkownika} oraz wczeœniej wygenerowanego {klucza publicznego} odsy³ana jest do \texttt{klienta} jako odpowiedŸ na asynchroniczne zapytanie REST. \texttt{Klient} po zakoñæzeniu ¿¹dania zapisuje swoj¹ \texttt{parê kluczy} do plików. W przypadku generowania ponownie \texttt{pary kluczy}, stara para zostaje nadpisana na \texttt{mediatorze} oraz w aplikacji \texttt{klienta}. W takim przypadku, nale¿y zabezpieczyæ istniej¹cy plik zawieraj¹cy \texttt{klucz publiczny} w celu póŸniejszej weryfikacji \texttt{plików} podpisanych przy pomocy odpowiadaj¹cemu mu \texttt{kluczowi prywatnemu}. Rysunki \ref{generateKeyActivity1} i \ref{generateKey1} przedstawiaj¹ proces generowania pary kluczy.

\newpage

\textbf{Diagram aktywnoœci dla generowania pary kluczy}\\

\begin{figure}[h!]
\begin{center}
\includegraphics[width=0.8\textwidth]{generateKeyActivity.pdf}
\end{center}
\caption{Diagram aktywnoœci - generowanie pary kluczy.} \label{generateKeyActivity1}
\end{figure}

\newpage

\textbf{Diagram sekwencji dla generowania pary kluczy}\\

\begin{figure}[h!]
\begin{center}
\includegraphics[width=0.7\textwidth]{generateKey.pdf}
\end{center}
\caption{Diagram sekwencji - generowanie pary kluczy.} \label{generateKey1}
\end{figure}

\newpage

\subsubsection{Podpisywanie pliku}

Proces podpisywania pliku równierz odbywa siê w oparciu o model matematyczny przedstawiony w rozdziale 3. Aby podpisaæ plik \texttt{u¿ytkownik} powinien posiadaæ wczeœniej wygenerowan¹ \texttt{parê kluczy}. Nastêpnie plik do podpisu powinien zostaæ wczytany w aplikacji \texttt{klient}. Z za³adowanego wczeœniej \texttt{pliku} zostaje obliczony \texttt{skrót} kryptograficzny \texttt{SHA512}. \texttt{Skrót} ten jest nastêpnie podpisywany \texttt{kluczem prywatnym u¿ytkownika}. Czêsciowo podpisany \texttt{plik} oraz jego \texttt{skrót} wysy³ane s¹ w ¿¹daniu podpisu do \texttt{serwera dostêpowego}. Nag³ówek ¿¹dania zawiera \texttt{klucz serwisowy} i \texttt{token}. \texttt{Serwera dostêpowy} po pomyœlnym zautoryzowaniu \texttt{u¿ytkownika} przesy³a do \texttt{mediatora} otrzymany \texttt{podpis} i \texttt{skrót} oraz \texttt{klucz serwisowy}  \texttt{u¿ytkownika}. \texttt{Mediator} podpisuje otrzymany \texttt{skrót} przy pomocy \texttt{prywatnego klucza finalizuj¹cego}, a nastêpnie sk³ada go z podpisem dokonanym przez \texttt{klienta}. Z³o¿ony podpis odsy³any jest jako odpowiedŸ asynchroniczna do \texttt{serwera dostêpowego}, który odsy³a go do  \texttt{klienta}. \texttt{Podpis} zapisywany jest automatycznie do pliku. Proces podpisywania \texttt{pliku} zosta³ przedstawiony na rysunkach \ref{signFileActivity1} i \ref{signFile1}

\newpage

\textbf{Diagram aktywnoœci dla podpisywania pliku}\\

\begin{figure}[h!]
\begin{center}
\includegraphics[width=0.8\textwidth]{signFileActivity.pdf}
\end{center}
\caption{Diagram aktywnoœci - podpisywanie pliku.} \label{signFileActivity1}
\end{figure}

\newpage

\textbf{Diagram sekwencji dla podpisywania pliku}\\

\begin{figure}[h!]
\begin{center}
\includegraphics[width=0.7\textwidth]{signFile.pdf}
\end{center}
\caption{Diagram sekwencji - podpisywanie pliku.} \label{signFile1}
\end{figure}

\newpage

\subsubsection{Weryfikacja podpisu}

Aby zweryfikowaæ podpisany \texttt{plik} nale¿y wczytaæ go w aplikacji \texttt{klienckiej}, nastêpnie nale¿y wczytaæ \texttt{podpis} pliku oraz \texttt{klucz publiczny} nale¿¹cy do \texttt{u¿ytkownika}, który ten plik podpisa³. Weryfikacja nastêpuje wtedy w ca³oœci po stronie klienta. Proces ten zosta³ dok³adniej przedstawiony w projekcie aplikacji klienta.

\subsection{Projekt serwera dostêpowego}

\subsubsection{Komponenty serwera dostêpowego}

\begin{figure}[h!]
\begin{center}
\includegraphics[width=0.7\textwidth]{registrationServer.pdf}
\end{center}
\caption{Interakcje miêdzy komponentami serwera dostêpowego.} \label{registrationServer1}
\end{figure}

\newpage

\subsection{Projekt serwera mediatora}

\subsubsection{Komponenty mediatora}

\begin{figure}[h!]
\begin{center}
\includegraphics[width=0.7\textwidth]{mediator.pdf}
\end{center}
\caption{Interakcje miêdzy komponentami mediatora.} \label{mediator1}
\end{figure}

\newpage

\subsection{Projekt aplikacji klienta}

\subsubsection{Komponenty klienta}

\begin{figure}[h!]
\begin{center}
\includegraphics[width=0.7\textwidth]{client.pdf}
\end{center}
\caption{Interakcje miêdzy komponentami Klienta.} \label{client1}
\end{figure}

\newpage

\section{Implementacja systemu}

\subsection{Implementacja serwera dostêpowego}
\subsubsection{Realizacja modu³u ...}
\subsubsection{Realizacja filtrów zapytañ}

\begin{lstlisting}[language=Java, frame=lines, numberstyle=\tiny, stepnumber=1, caption=RequestFilter.java., firstnumber=1]
package net.ddns.falcoboss.registrationserver.security;


import java.io.IOException;
import java.util.logging.Logger;

import javax.ejb.EJB;
import javax.ejb.Local;
import javax.ejb.Stateless;
import javax.ws.rs.container.ContainerRequestContext;
import javax.ws.rs.container.ContainerRequestFilter;
import javax.ws.rs.container.PreMatching;
import javax.ws.rs.core.Response;
import javax.ws.rs.ext.Provider;

import net.ddns.falcoboss.common.HTTPHeaderNames;
 
@Provider
@PreMatching
@Local
@Stateless
public class RequestFilter implements ContainerRequestFilter {
 
    private final static Logger log = Logger.getLogger(RequestFilter.class.getName());
 
    @EJB
    AuthenticatorBean authenticatorBean;
    
    @Override
    public void filter(ContainerRequestContext requestCtx) throws IOException {
    	  String path = requestCtx.getUriInfo().getPath();
        log.info( "Filtering request path: " + path );
        String serviceKey = requestCtx.getHeaderString(HTTPHeaderNames.SERVICE_KEY);

        if (!authenticatorBean.isServiceKeyValid(serviceKey)) {
            requestCtx.abortWith(Response.status(Response.Status.UNAUTHORIZED).build());
            return;
        }
 
        if (!path.startsWith( "service/login/" )) {
            String authToken = requestCtx.getHeaderString(HTTPHeaderNames.AUTH_TOKEN);
            if (!authenticatorBean.isAuthTokenValid(serviceKey, authToken)) {
                requestCtx.abortWith(Response.status(Response.Status.UNAUTHORIZED).build());
            }
        }
    }
}
\end{lstlisting}\label{requestFilter1} 

\newpage

\subsubsection{Filtr odpowiedzi}

\begin{lstlisting}[language=Java, frame=lines, numberstyle=\tiny, stepnumber=1, caption=RequestFilter.java., firstnumber=1]
package net.ddns.falcoboss.registrationserver.security;

import java.io.IOException;
import java.util.logging.Logger;

import javax.ws.rs.container.ContainerRequestContext;
import javax.ws.rs.container.ContainerResponseContext;
import javax.ws.rs.container.ContainerResponseFilter;
import javax.ws.rs.container.PreMatching;
import javax.ws.rs.ext.Provider;

import net.ddns.falcoboss.common.HTTPHeaderNames;

@Provider
@PreMatching
public class ResponseFilter implements ContainerResponseFilter {
 
    private final static Logger log = Logger.getLogger(ResponseFilter.class.getName());
 
    @Override
    public void filter(ContainerRequestContext requestCtx, 
        ContainerResponseContext responseCtx) throws IOException {
 
        log.info("Filtering REST Response");
 
        responseCtx.getHeaders().add("Access-Control-Allow-Origin", "*");
        responseCtx.getHeaders().add("Access-Control-Allow-Credentials", "true");
        responseCtx.getHeaders().add("Access-Control-Allow-Methods", "GET, POST, DELETE, PUT");
        responseCtx.getHeaders().add("Access-Control-Allow-Headers", HTTPHeaderNames.
        SERVICE_KEY + ", " + HTTPHeaderNames.AUTH_TOKEN);
    }
}
\end{lstlisting}\label{responseFilter1} 

\newpage

\section{Testowanie i ocena jakoœci systemu}

\subsection{Instalowanie i konfiguracja systemu}

\subsubsection{Œrodowisko testowe}

Œrodowisko testowe sk³ada siê z 3 komputerów.

\begin{itemize}
  \item \texttt{Rasspbery PI 2}, 4-rdzeniowy procesor ARM Cortex-A7 900MHz, 1GB RAM;
  \item \texttt{Lenovo T540}, 4-rdzeniowy procesor i7-4700MQ 2,4GHz, 8GB RAM;
  \item \texttt{Lenovo Y550}, 2-rdzeniowy procesor Core 2 Duo T6500 2,1GHZ, 4GB RAM;
\end{itemize}

\texttt{Mediator} uruchomiony zosta³ na \texttt{Rasspbery PI2} z baz danych \texttt{MySql 5.7}.
\texttt{Serwer dostêpowy} uruchomiony zosta³ na \texttt{Lenovo T540} z baz danych \texttt{Oracle 11g}.
\texttt{Klient} i \texttt{Klient administrator} dzia³aj na \texttt{Lenovo Y550}.
\texttt{Mediator} i \texttt{Serwer dostêpowy} uruchamiane s¹ wewn¹trz kontenerów hostowanych przez serwer aplikacji \texttt{Glassfiash 4.1.1 Full Platform}.
Na wszystkich komputerach zainstalowana zosta³a  Maszyna wirtualna Javy \texttt{JVM 1.8.0\_60-b27}.
Komputery po³¹czone s¹ za pomoc¹ sieci LAN o maksymalnej przepustowoœci 100MB/s.
Domyœlna biblioteka serwera \texttt{Glassfiash 4.1.1 Full Platform}  odpowiadaj¹ca za persystencje obiektów \texttt{EclipseLink 2.6.1-RC1} zawiera b³¹d i uniemo¿liwia poprawne dzia³anie z baz¹ danych, dlatego wymagana jest aktualizacja biblioteki do wersji 2.6.2.
Na rysunku \ref{testEnviroment1} przedstawiona zosta³a konfiguracja poszczególnych elementów systemu.

\newpage

\begin{figure}[h!]
\begin{center}
\includegraphics[width=0.7\textwidth]{testEnviroment.pdf}
\end{center}
\caption{Œrodowisko testowe.} \label{testEnviroment1}
\end{figure}


\subsubsection{Przygotowanie bazy danych}

\begin{lstlisting}[language=sql, frame=lines, numberstyle=\tiny, stepnumber=1, caption=Tworzenie bazy danych i u¿ytkownika bazy danych, firstnumber=1]
-- po³¹czenie z systemem bazodanowym jako root
mysql --host=localhost --user=root -p

-- usuwanie bazy danych je¿eli istnieje
mysql> DROP DATABASE IF EXISTS secstorage;

-- tworzenie bazy danych
mysql> CREATE DATABASE secstorage;

-- polaczenie z utworzon¹ baz¹ danych
mysal> use secstorage; 

-- usuwanie u¿ytkownika
mysql> DROP USER 'mainStorage'@'localhost';

-- utworzenie u¿ytkownika
mysql> CREATE USER 'mainStorage'@'localhost' IDENTIFIED BY 'registrationServer1';

-- nadanie utworzonemu u¿ytkownikowi wszystkich praw do utworzonej bazy
mysql> GRANT ALL PRIVILEGES ON *.* TO 'mainStorage'@'localhost';
\end{lstlisting}\label{database1} 


\begin{lstlisting}[language=bash, frame=lines, numberstyle=\tiny, stepnumber=1, caption=Tworzenie zasobu JDBC., firstnumber=1]

\subsubsection{Konfiguracja serwera Java EE}

asadmin create-jdbc-connection-pool
--datasourceclassname=com.mysql.jdbc.jdbc2.optional.MysqlDataSource
--restype=javax.sql.DataSource
--property="user=mainStorage:password=registrationServer1:url=
jdbc\:mysql\://localhost\:3306/secstorage" mysqlRegPool

asadmin create-jdbc-resource
--connectionpoolid mysqlRegPool jdbc/secstorage
\end{lstlisting}\label{jdbcResource1} 

\subsection{Realizacja testów}

\subsubsection{Testy jednostkowe}

\subsubsection{Testy integracyjne}

\subsubsection{Testy akceptacyjne}

\subsection{Ocena wydajnoœci operacji generowania kluczy}

\subsection{Ocena wydajnoœci transmisji danych}

\subsection{Ocena zachowania w przypadku awarii}

\subsection{Ocena bezpieczeñstwa}

\section{Podsumowanie}

\newpage

\begin{thebibliography}{99}

\bibitem{JavaEE6Leksykon1}Arun Gupta. \emph{Java EE 6 Leksykon kieszonkowy}, Wydawnictwo HELION, Gliwice, 2013. ISBN 978-83-246-6640-9.

\bibitem{JavaEE6Przewodnik1}Eric Jendrock, Ian Evans, Devika Gollapudi, Kim Haase, Chinmayee Srivathsa. \emph{Java EE 6 Przewodnik, Wydanie IV}, Wydawnictwo HELION, Gliwice, 2012. ISBN 978-83-246-3847-5.

\bibitem{JavaEEZaawansowany6Przewodnik1}Eric Jendrock, Ricardo Cervera-Navarro, Ian Evans, Devika Gollapudi, Kim Haase, William Markito, Chinmayee Srivathsa. \emph{Java EE 6 Zaawansowany Przewodnik, Wydanie IV}, Wydawnictwo HELION, Gliwice, 2012. ISBN 978-83-246-7393-3.

\bibitem{Rest1} Bhakti Mehta. \emph{REST Najlepsze praktyki i wzorce w jêzyku Java}, Wydawnictwo HELION, Gliwice, 2015. ISBN 978-83-283-0644-8.

\bibitem{SieciKomputerowe1}Andrew S. Tanenbaum. \emph{Sieci Komputerowe}, Wydawnictwo HELION, Gliwice, 2004. ISBN 83-7361-557-1. Bezpieczeñstwo w sieciach komputerowych, s.641-740.

\bibitem{InzynieriOprogramowania1}Bernd Bruegge, Allen H. Dutoit. \emph{In¿ynieria oprogramowania w ujêciu obiektowym. UML, wzorce projektowe i Java}, Wydawnictwo HELION, Gliwice, 2012. ISBN 978-83-246-2872-8.

\bibitem{Kryptografia1}William Stallings. \emph{Kryptografia i bezpieczeñstwo sieci komputerowych. Matematyka szyfrów i techniki kryptologii}, Wydawnictwo HELION, Gliwice, 2010. ISBN 978-83-246-2986-2.

\bibitem{mRSA1}Miros³aw Kutylowski, Przemys³aw Kubiak. \emph{Mediated RSA cryptography specification for additive private key splitting (mRSAA)}, Internet Szkic, 2013 [dostêp 15 grudnia 2015] Dostêpne w internecie:
\url{https://tools.ietf.org/html/draft-kutylowski-mrsa-algorithm-03}

\bibitem{Oracle1}\emph{Oracle® Security Developer Tools Reference}, ¯ród³o, 2006 [dostêp 15 grudnia 2015] Dostêpne w internecie:
\url{https://docs.oracle.com/cd/B28196_01/idmanage.1014/b28165/crypto.htm}

\bibitem{KryptografiaAsymetrczna1}\emph{Kryptografia asymetryczna i jej zastosowanie w algorytmach komunikacji}, ¯ród³o, 2006 [dostêp 29 grudnia 2015] Dostêpne w internecie:
\url{http://kis.pwszchelm.pl/publikacje/V/Bartyzel.pdf}

\bibitem{SystemyRozproszone1}\emph{Systemy rozproszone}, Wyk³ad, 2006 [dostêp 28 grudnia 2015] Dostêpne w internecie:
\url{http://wazniak.mimuw.edu.pl/index.php?title=Systemy_rozproszone}

\bibitem{SystemyEE1}Zofia Kruczkiewicz. \emph{Modelowanie i analiza systemów informatycznych 1}, Wyk³ady, 2014 [dostêp 28 grudnia 2015] Dostêpne w internecie:
\url{http://zofia.kruczkiewicz.staff.iiar.pwr.wroc.pl/wyklady/analizasi/}

\bibitem{JavaEETutorial1}\emph{Java Platform, Enterprise Edition: The Java EE Tutorial}, ¯ród³o, 2014 [dostêp 15 grudnia 2015] Dostêpne w internecie:
\url{https://docs.oracle.com/javaee/7/JEETT.pdf}

\bibitem{JaxRSFilters1}\emph{Filters and Handlers Revisited}, ¯ród³o, 2011 [dostêp 24 stycznia 2015] Dostêpne w internecie:
\url{https://java.net/projects/jax-rs-spec/pages/PreMatchingFilters}

\bibitem{Wikipedia1}\emph{Wikipedia}, ¯ród³o, 2015, [dostêp 24 stycznia 2016] Dostêpne w internecie:
\url{http://wikipedia.org}

\end{thebibliography}

\end{document}
